---
layout: post
title: Activity的启动流程分析
author: clow
date: 2018-02-15 22:10:33
categories:
- Android
tags: Android
---
## 1.概述
基于Android10源码分析更新
```
Intent intent = new Intent(this, MainActivity.class);
this.startActivity(intent);
```
相信每位Android开发者对上面的代码都写过无数次了，那么问题来了：
- 这个代码是如何启动一个Activity的？
- 内部做了哪些事情？
- onCreate这些生命周期是何时执行的？
- Activity对象何时创建的？
- 视图是怎么处理以及何时可见的？
- 根activity（第一个activity）又是如何启动的？
-------
我们不了解内部实现的原理，在平时开发中好像也没有什么问题。其实不然，解决这些问题后，你会对Android系统有更深层次的理解，也会学习到系统源码优秀的设计。并且对解决一些高级问题和深入的性能优化问题有很大帮助，阅读优秀的源码是技术进阶的必要阶段。但另一方面，系统源码是很庞大繁杂的，我们需要带着问题抓住**主流程**，不能陷入代码细节——这是阅读系统源码以及其他第三方库源码的正确姿势。

## 2. 入口main()
学过Java的都知道，应用程序入口是`public static void main(String[] args)`方法，基于Java的Android也一样，通过上节我们讲Android中消息机制已经知道，Android应用程序的入口在`ActivityThread.main()`方法中，一切的起源都从main()方法开始：
```
    ...
    final ApplicationThread mAppThread = new ApplicationThread();
    final H mH = new H();
    ...

    public static void main(String[] args){
         ...
        //初始化Looper
        Looper.prepareMainLooper();

        ...

        //创建ActivityThread对象 实例化了上面的ApplicationThread和mH，就是handler 这个mH很重要后续会详解
        ActivityThread thread = new ActivityThread();
        //建立Binder通道 (创建新线程) 发送出创建Application的消息
        thread.attach(false, startSeq);

        ...
        
        //开启循环 主线程进入无限循环状态，等待接收消息
        Looper.loop();
    }
```
`ActivityThread thread = new ActivityThread()`创建ActivityThread实例，同时会创建ApplicationThread实例，ApplicationThread是ActivityThread中的一个内部类。然后调用了attach方法：
```
    private void attach(boolean system, long startSeq) {
        sCurrentActivityThread = this;
        mSystemThread = system;
        if (!system) {
            android.ddm.DdmHandleAppName.setAppName("<pre-initialized>",
                                                    UserHandle.myUserId());
            RuntimeInit.setApplicationObject(mAppThread.asBinder());
            //获得IActivityManager实例
            final IActivityManager mgr = ActivityManager.getService();
            try {
            	//把ApplicationThread实例关联到AMS中
                mgr.attachApplication(mAppThread, startSeq);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
            ...
        } 
        ...
    }

```
我们看下`ActivityManager.getService()`内部执行流程
```
    /**
     * @hide
     */
    public static IActivityManager getService() {
        return IActivityManagerSingleton.get();
    }

    private static final Singleton<IActivityManager> IActivityManagerSingleton =
            new Singleton<IActivityManager>() {
                @Override
                protected IActivityManager create() {
                    final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
                    final IActivityManager am = IActivityManager.Stub.asInterface(b);
                    return am;
                }
            };
    
```
看到IBinder这个标志，这里你应该明白了：这里是获取一个跨进程的服务。获取的什么服务呢？答案就是`ActivityManagerService`，它继承于IActivityTaskManager.Stub，是个Binder对象，并且是通过单例提供服务的。

接着看下`mgr.attachApplication(mAppThread, startSeq)`方法，最终会走到AMS的attachApplication：
```
    @Override
    public final void attachApplication(IApplicationThread thread, long startSeq) {
        if (thread == null) {
              throw new SecurityException("Invalid application interface");
        }
        synchronized (this) {
            int callingPid = Binder.getCallingPid();
            final int callingUid = Binder.getCallingUid();
            final long origId = Binder.clearCallingIdentity();
            attachApplicationLocked(thread, callingPid, callingUid, startSeq);
            Binder.restoreCallingIdentity(origId);
          }
      }
```

接着走到`attachApplicationLocked()`方法很长，这里保留重要的几点：
```
    private final boolean attachApplicationLocked(IApplicationThread thread,
            int pid, int callingUid, long startSeq) {

			...
				//1、IPC操作，创建绑定Application
                thread.bindApplication(processName, appInfo, providers, null, profilerInfo,
                        null, null, null, testMode,
                        mBinderTransactionTrackingEnabled, enableTrackAllocation,
                        isRestrictedBackupMode || !normalMode, app.isPersistent(),
                        new Configuration(app.getWindowProcessController().getConfiguration()),
                        app.compat, getCommonServicesLocked(app.isolated),
                        mCoreSettingsObserver.getCoreSettingsLocked(),
                        buildSerial, autofillOptions, contentCaptureOptions);
			...
            // 2、赋值IApplicationThread
            app.makeActive(thread, mProcessStats);
			...
			
        // See if the top visible activity is waiting to run in this process...
        if (normalMode) {
            try {
            	//3、通过ATMS启动 根activity
                didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());
            } catch (Exception e) {
                Slog.wtf(TAG, "Exception thrown launching activities in " + app, e);
                badApp = true;
            }
        }
		...
}
```
AMS的attachApplicationLocked方法主要三件事：
1. 调用IApplicationThread的bindApplication方法，IPC操作，创建绑定Application；
2. 通过makeActive方法赋值IApplicationThread，即验证了上面的猜测（创建进程后赋值）；
3. 通过ATMS启动根activity

