---
layout: post
title: 04-Paint详解
author: clow
date: 2021-04-10 21:10:10
categories:
- Android
tags: 自定义View
---

# 一、前言
在上一节《Canvas绘图基础详解》我们说到Canvas绘图有三个基本要素：`Canvas`、`绘图坐标系`以及`Paint`，上一节我们详细介绍了`Canvas`和`绘图坐标系`的使用。这一节我们就来详细讲讲`Paint`的一些使用方式。`Paint`就是画笔的意思，用于设置绘制风格，如:线宽(笔触粗细)、颜色、透明度和填充风格等等。

# 二、常用api

- setFlags(@PaintFlag int flags): //添加标识，用以实现特定的效果
- setAntiAlias(boolean aa): 设置是否使用抗锯齿功能，会消耗较大资源，绘制图形速度会变慢。
- setDither(boolean dither): 设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰
- setStyle(Paint.Style style)： 设置画笔的样式，为FILL，FILL_AND_STROKE，或STROKE
- setStrokeWidth(float width)： 当画笔样式为STROKE或FILL_AND_STROKE时，设置笔刷的粗细度
- setStrokeCap(Paint.Cap cap)： 当画笔样式为STROKE或FILL_AND_STROKE时，设置线头的形状， 如圆形样Cap.ROUND,或方形样式Cap.SQUARE
-  setStrokeJoin(Paint.Join join)： 设置结合处的样子，Miter:结合处为锐角， Round:结合处为圆弧：BEVEL：结合处为直线
- setStrokeMiter(float miter)：它用于设置 MITER 型拐角的延长线的最大值。
- setColor(int color): 设置绘制的颜色，使用颜色值来表示，该颜色值包括透明度和RGB颜色。
- setARGB(int a,int r,int g,int b): 设置绘制的颜色，a代表透明度，r，g，b代表颜色值。
- setAlpha(int a): 设置绘制图形的透明度。
- setShader(Shader shader)： 设置图像效果，使用Shader可以绘制出各种渐变效果
- setXfermode(Xfermode xfermode)： 设置图形重叠时的处理方式，如合并，取交集或并集，经常用来制作橡皮的擦除效果
- setFilterBitmap(boolean filter)： 如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作， 加快显示速度，本设置项依赖于dither和xfermode的设置
- setMaskFilter(MaskFilter maskfilter)： 设置MaskFilter，可以用不同的MaskFilter实现滤镜的效果，如滤化，立体等
- setColorFilter(ColorFilter colorfilter)： 设置颜色过滤器，可以在绘制颜色时实现不用颜色的变换效果
- setPathEffect(PathEffect effect) 设置绘制路径的效果，如点画线等
- setShadowLayer(float radius ,float dx,float dy,int color)：在图形下面设置阴影层，产生阴影效果， radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色

- setFakeBoldText(boolean fakeBoldText)： 模拟实现粗体文字，设置在小字体上效果会非常差
- etSubpixelText(boolean subpixelText)： 设置该项为true，将有助于文本在LCD屏幕上的显示效果
- setTextAlign(Paint.Align align)： 设置绘制文字的对齐方向
- setTextScaleX(float scaleX)： 设置绘制文字x轴的缩放比例，可以实现文字的拉伸的效果
- setLetterSpacing(float letterSpacing): 设置字符间的间距
- setTextSize(float textSize)： 设置绘制文字的字号大小
- setTextSkewX(float skewX)： 设置斜体文字，skewX为倾斜弧度
- setTypeface(Typeface typeface)： 设置Typeface对象，即字体风格，包括粗体，斜体以及衬线体，非衬线体等
- setUnderlineText(boolean underlineText)： 设置带有下划线的文字效果
- setStrikeThruText(boolean strikeThruText)： 设置带有删除线的效果

- float ascent( )：测量baseline之上至字符最高处的距离
- float descent()：baseline之下至字符最低处的距离
- int breakText(char[] text, int index, int count, float maxWidth, float[] measuredWidth)： 检测一行显示多少文字
- clearShadowLayer( )：清除阴影层
- ...

# 三、用例测试

### setFlags(int flags)

常用的flag有如下几种：
``` java
    Paint.ANTI_ALIAS_FLAG   //抗锯齿标志
    Paint.FILTER_BITMAP_FLAG    //使位图双线性过滤的标志
    Paint.DITHER_FLAG   //有利抖动
    Paint.UNDERLINE_TEXT_FLAG   //下划线
    Paint.STRIKE_THRU_TEXT_FLAG //删除线
    Paint.FAKE_BOLD_TEXT_FLAG   //加粗
    Paint.LINEAR_TEXT_FLAG  //文本平滑线性缩放
    Paint.SUBPIXEL_TEXT_FLAG    //文本的亚像素定位标志
    Paint.EMBEDDED_BITMAP_TEXT_FLAG //允许在绘制文本时使用位图字体
```
举个栗子：

设置抗锯齿 `mPaint.setFlags(Paint.ANTI_ALIAS_FLAG)`  它等价于 `mPaint.setAntiAlias(true)`。

设置多个flag `mPaint.setFlags(Paint.ANTI_ALIAS_FLAG | Paint.UNDERLINE_TEXT_FLAG)` 同时设置抗锯齿和下划线。

### 设置抗锯齿 setAntiAlias(boolean aa)

抗锯齿是指在图像中，物体边缘总会或多或少的呈现三角形的锯齿，而抗锯齿就是指对图像边缘进行柔化处理，使图像边缘看起来更平滑，更接近实物的物体。

- true：柔化处理
- false：不柔化处理

![抗锯齿](https://ForLovelj.github.io/img/抗锯齿.png)

### 设置防抖动 setDither(boolean dither)

这个api现在用的不多了，因为现在的 `Android` 版本的绘制，默认的色彩深度已经是 `32` 位的 `ARGB_8888` ，效果已经足够清晰了。只有当你向自建的 `Bitmap` 中绘制，并且选择 `16` 位色的 `ARGB_4444` 或者 `RGB_565` 的时候，开启它才会有比较明显的效果。

引用wiki的一张图来展示它的效果：

![防抖动](https://ForLovelj.github.io/img/防抖动.png)

### 设置Paint的样式 setStyle(Paint.Style style)

画笔样式有三种，默认是`Paint.Style.FILL`模式：

- Paint.Style.FILL：填充内部（例如这种模式画一个圆圆内部颜色是被填充的）
- Paint.Style.STROKE ：描边（内部不被填充，可以用来绘制圆环）
- Paint.Style.FILL_AND_STROKE ：填充内部和描边（展示效果和FILL看起来是一样的）

``` kotlin
    mPaint.style = Paint.Style.FILL //设置填充模式
    canvas.drawCircle(200f,300f,100f,mPaint)
    
    mPaint.style = Paint.Style.STROKE   //设置描边模式
    canvas.drawCircle(500f,300f,100f,mPaint)
    
    mPaint.style = Paint.Style.FILL_AND_STROKE  //设置描边加填充模式
    canvas.drawCircle(800f,300f,100f,mPaint)
```

![setStyle](https://ForLovelj.github.io/img/setStyle.png)

### 设置画笔的粗细 setStrokeWidth(float width)

设置线条的宽度，单位为像素，默认值是 0。

``` kotlin
    mPaint.style = Paint.Style.STROKE   //设置描边模式

    mPaint.strokeWidth = 1f
    canvas.drawCircle(200f,300f,100f,mPaint)

    mPaint.strokeWidth = 10f
    canvas.drawCircle(500f,300f,100f,mPaint)

    mPaint.strokeWidth = 40f
    canvas.drawCircle(800f,300f,100f,mPaint)
```

![setStrokeWidth](https://ForLovelj.github.io/img/setStrokeWidth.png)

> 线条宽度 0 和 1 的区别<br>
默认情况下，线条宽度为 0，但你会发现，这个时候它依然能够画出线，线条的宽度为 1 像素。那么它和线条宽度为 1 有什么区别呢？<br>
其实这个和「几何变换」有关：你可以为 `Canvas` 设置 `Matrix` 来实现几何变换（如放大、缩小、平移、旋转），在几何变换之后 Canvas 绘制的内容就会发生相应变化，包括线条也会加粗，例如 `2` 像素宽度的线条在 Canvas 放大 `2` 倍后会被以 `4` 像素宽度来绘制。而当线条宽度被设置为 `0` 时，它的宽度就被固定为 `1` 像素，就算 `Canvas` 通过几何变换被放大，它也依然会被以 `1` 像素宽度来绘制。`Google` 在文档中把线条宽度为 `0` 时称作「hairline mode（发际线模式）」。

### 设置线头的形状 setStrokeCap(Paint.Cap cap)

线头形状有三种，默认为 `Paint.Cap.BUTT` :

- Paint.Cap.BUTT:   平头
- Paint.Cap.ROUND:  圆头
- Paint.Cap.SQUARE: 方头

当线条的宽度是 1 像素时，这三种线头的表现是完全一致的，全是 1 个像素的点；而当线条变粗的时候，它们就会表现出不同的样子：

``` kotlin
    mPaint.strokeWidth = 40f
    mPaint.strokeCap = Paint.Cap.BUTT
    canvas.drawLine(100f,100f,800f,100f,mPaint)

    mPaint.strokeCap = Paint.Cap.ROUND
    canvas.drawLine(100f,200f,800f,200f,mPaint)

    mPaint.strokeCap = Paint.Cap.SQUARE
    canvas.drawLine(100f,300f,800f,300f,mPaint)
```

![setStrokeCap](https://ForLovelj.github.io/img/setStrokeCap.png)

图上的红色直线是额外加上便于理解的，有了红线作为辅助，可以清晰的看出线的三种线头的区别。

### 设置拐角的形状 setStrokeJoin(Paint.Join join)

拐角形状有三种，默认为 `Paint.Join.MITER` :

- Paint.Join.MITER：尖角
- Paint.Join.BEVEL：平角
- Paint.Join.ROUND：圆角

``` kotlin
    mPaint.style = Paint.Style.STROKE
    mPaint.strokeWidth = 40f
    //画一个三角形
    val path = Path().apply {
        moveTo(100f,100f)
        lineTo(400f,100f)
        lineTo(400f,300f)
        close()
    }

    mPaint.strokeJoin = Paint.Join.MITER    //尖角
    canvas.drawPath(path,mPaint)

    canvas.translate(0f,300f)
    mPaint.strokeJoin = Paint.Join.BEVEL    //平角
    canvas.drawPath(path,mPaint)

    canvas.translate(0f,300f)
    mPaint.strokeJoin = Paint.Join.ROUND    //圆角
    canvas.drawPath(path,mPaint)
```

![setStrokeJoin](https://ForLovelj.github.io/img/setStrokeJoin.png)

### setStrokeMiter(float miter)

这个方法是对于 `setStrokeJoin()` 的一个补充，它用于设置 `MITER` 型拐角的延长线的最大值。所谓「延长线的最大值」，是这么一回事：

当线条拐角为 `MITER` 时，拐角处的外缘需要使用延长线来补偿：

![setStrokeMiter1](https://ForLovelj.github.io/img/setStrokeMiter1.png)

而这种补偿方案会有一个问题：如果拐角的角度太小，就有可能由于出现连接点过长的情况。比如这样：

![setStrokeMiter2](https://ForLovelj.github.io/img/setStrokeMiter2.png)

所以为了避免意料之外的过长的尖角出现， `MITER` 型连接点有一个额外的规则：当尖角过长时，自动改用 `BEVEL` 的方式来渲染连接点。例如上图的这个尖角，在默认情况下是不会出现的，而是会由于延长线过长而被转为 `BEVEL` 型连接点：

![setStrokeMiter3](https://ForLovelj.github.io/img/setStrokeMiter3.png)

`setStrokeMiter(miter)` 方法中 `miter` 参数是对于转角长度的限制，具体来讲，是指尖角的外缘端点和内部拐角的距离与线条宽度的比:

![setStrokeMiter4](https://ForLovelj.github.io/img/setStrokeMiter4.png)

用几何知识很容易得出这个比值的计算公式：如果拐角的大小为 θ ，那么这个比值就等于 1/sin(θ/2) 。

这个 miter limit 的默认值是 4，对应的是一个大约 29° 的锐，默认情况下，大于这个角的尖角会被保留，而小于这个夹角的就会被「削成平头」。

```kotlin
    mPaint.style = Paint.Style.STROKE
    mPaint.strokeWidth = 40f

    //画一个等边直角三角形
    val path = Path().apply {
        moveTo(100f,100f)
        lineTo(300f,100f)
        lineTo(100f,300f)
        close()
    }
    //1度=π/180≈0.01745弧度，1弧度=180/π≈57.3度
    mPaint.strokeMiter = (1 / sin(20 * Math.PI/180)).toFloat()  //大于这个40°的尖角会被保留，小于的就被削成平头
    canvas.drawPath(path,mPaint)

    canvas.translate(0f,300f)
    mPaint.strokeMiter = (1/sin(30 * Math.PI/180)).toFloat()    //大于这个60°的尖角会被保留，小于的就被削成平头
    canvas.drawPath(path,mPaint)

    canvas.translate(0f,300f)
    mPaint.strokeMiter = (1/sin(60*Math.PI/180)).toFloat()  //大于这个120°的尖角会被保留，小于的就被削成平头
    canvas.drawPath(path,mPaint)
```

![setStrokeMiter](https://ForLovelj.github.io/img/setStrokeMiter.png)

### setXfermode(Xfermode xfermode)

在SDK中 `Xfermode `有三个子类：`AvoidXfermode`, `PixelXorXfermode` 和`PorterDuffXfermode`，前两个类在API 16被遗弃了，这里不作介绍。`PorterDuffXfermode` 类主要用于图形合成时的图像过渡模式计算，其概念来自于1984年在ACM SIGGRAPH计算机图形学出版物上发表了”Compositing digital images（合成数字图像）”的Tomas Porter和Tom Duff，合成图像的概念极大地推动了图形图像学的发展，`PorterDuffXfermode` 类名就来源于这俩人的名字组合PorterDuff。而这篇论文所论述的操作，都是关于 Alpha 通道（也就是我们通俗理解的「透明度」）的计算的，后来人们就把这类计算称为Alpha 合成 ( [Alpha Compositing](https://en.wikipedia.org/wiki/Alpha_compositing) ) 。

`PorterDuffXfermode` 只有这一个构造方法 `PorterDuffXfermode(PorterDuff.Mode mode)`，里面传入了一个`PorterDuff.Mode`，下面是android SDK中`PorterDuff`的`Mode`枚举类型定义:

```java
public enum Mode {
    //清除模式［0，0］，即最终所有点的像素的alpha 和color 都为 0，所以画出来的效果只有白色背景
    CLEAR       (0),
    //只保留源图像的 alpha 和 color ，所以绘制出来只有源图 (先绘制的是目标图，后绘制的是源图)
    SRC         (1),
    //只保留目标图像的 alpha 和 color，所以绘制出来的只有目标图
    DST         (2),
    //在目标图片顶部绘制源图像,从命名上也可以看出来就是把源图像绘制在上方
    SRC_OVER    (3),
    //将目标图像绘制在上方
    DST_OVER    (4),
    //在两者相交的地方绘制源图像，并且绘制的效果会受到目标图像对应地方透明度的影响
    SRC_IN      (5),
    //在两者相交的地方绘制目标图像，并且绘制的效果会受到源图像对应地方透明度的影响
    DST_IN      (6),
    //在不相交的地方绘制源图像，相交处根据目标alpha进行过滤，目标色完全不透明时则完全过滤，完全透明则不过滤
    SRC_OUT     (7),
    //在不相交的地方绘制目标图像，相交处根据源图像alpha进行过滤，完全不透明处则完全过滤，完全透明则不过滤
    DST_OUT     (8),
    //源图像和目标图像相交处绘制源图像，不相交的地方绘制目标图像，并且相交处的效果会受到源图像和目标图像alpha的影响
    SRC_ATOP    (9),
    //源图像和目标图像相交处绘制目标图像，不相交的地方绘制源图像，并且相交处的效果会受到源图像和目标图像alpha的影响
    DST_ATOP    (10),
    //在不相交的地方按原样绘制源图像和目标图像，相交的地方受到对应alpha和色值影响
    XOR         (11),
    //该模式处理过后，会感觉效果变暗，即进行对应像素的比较，取较暗值，如果色值相同则进行混合
    DARKEN      (12),
    //该模式处理过后，会感觉效果变亮，如果在均完全不透明的情况下 ，色值取源色值和目标色值中的较大值
    LIGHTEN     (13),
    //正片叠底，即查看每个通道中的颜色信息，并将基色与混合色复合。结果色总是较暗的颜色。任何颜色与黑色复合产生黑色。任何颜色与白色复合保持不变。当用黑色或白色以外的颜色绘画时，绘画工具绘制的连续描边产生逐渐变暗的颜色。
    MULTIPLY    (14),
    //滤色
    SCREEN      (15),
    //饱和度叠加
    ADD         (16),
    //叠加
    OVERLAY     (17);
    Mode(int nativeInt) {
        this.nativeInt = nativeInt;
    }
    /**
     * @hide
     */
    public final int nativeInt;
}
```
> 具体来说， PorterDuff.Mode 一共有 18 个，可以分为两类：<br>
>
>   1. Alpha 合成 (Alpha Compositing)<br>
>   2. 混合 (Blending)<br>
>
> 第一类，Alpha 合成，其实就是 `PorterDuff` 这个词所指代的算法，一共描述了 12 种将两个图像共同绘制的操作（即算法）。<br>
> 看下效果图（引用自Google的[官方文档](https://developer.android.com/reference/android/graphics/PorterDuff.Mode)）：
>
>![source_dest](https://ForLovelj.github.io/img/source_dest.png)
> 
> Alpha 合成：
>
>![Alpha合成](https://ForLovelj.github.io/img/Alpha合成.png)
>
> 第二类，混合，也就是 `Photoshop` 等制图软件里都有的那些混合模式（multiply darken lighten 之类的）。这一类操作的是颜色本身而不是 `Alpha` 通道，并不属于 `Alpha` 合成，所以和 `Porter` 与 `Duff` 这两个人也没什么关系，不过为了使用的方便，它们同样也被 `Google` 加进了 `PorterDuff.Mode` 里。
>
> 效果图:
>
>![Blending_modes](https://ForLovelj.github.io/img/Blending_modes.png)
>
> 还有个 `ADD` 模式不知道为什么没有加在图上，我们待会儿用代码直接演示一下。

"Xfermode" 其实就是 "Transfer mode"，用 "X" 来代替 "Trans" 是一些美国人喜欢用的简写方式。严谨地讲， `Xfermode` 指的是你要绘制的内容和 `Canvas` 的目标位置的内容应该怎样结合计算出最终的颜色。但通俗地说，其实就是要你以绘制的内容作为源图像，以 `View` 中已有的内容作为目标图像，选取一个 `PorterDuff.Mode` 作为绘制内容的颜色处理方案。就像这样：

```kotlin
    val source = BitmapFactory.decodeResource(resources, R.mipmap.source)   //源图
    val dst = BitmapFactory.decodeResource(resources, R.mipmap.destination) //目标图
    val mode = PorterDuff.Mode.ADD  //PorterDuff 混合模式 剩下的自己修改mode执行代码
    val xfermode = PorterDuffXfermode(mode)

    val rect = RectF(0f,0f,canvas.width.toFloat(),canvas.height.toFloat())
    val saveCount = canvas.saveLayer(rect, mPaint)  //将绘制操作保存到新的图层 （离屏缓冲）

    val bitmapRect = RectF(0f,0f,source.width.toFloat(),source.height.toFloat())
    canvas.drawBitmap(dst,null,bitmapRect,mPaint) //绘制目标图
    mPaint.setXfermode(xfermode)    //设置混合模式
    canvas.drawBitmap(source,null,bitmapRect,mPaint) //绘制源图

    mPaint.setXfermode(null)    //清除混合模式
    canvas.restoreToCount(saveCount)    //还原画布
```

> ![PorterDuff_ADD](https://ForLovelj.github.io/img/PorterDuff_ADD.png)

`Xfermode` 使用很简单，不过需要注意的是必须要使用离屏缓冲（Off-screen Buffer），使用离屏缓冲有两种方式：
1. `Canvas.saveLayer()` 可以做短时的离屏缓冲。使用方法很简单，在绘制代码的前后各加一行代码，在绘制之前保存，绘制之后恢复，见上面示例代码。

2. `View.setLayerType()` 是直接把整个 `View` 都绘制在离屏缓冲中。 `setLayerType(LAYER_TYPE_HARDWARE)` 是使用 `GPU` 来缓冲， `setLayerType(LAYER_TYPE_SOFTWARE)` 是直接直接用一个 `Bitmap` 来缓冲.

如果没有特殊需求，一般选用第一种方法 `Canvas.saveLayer()` 来设置离屏缓冲，以此来获得更高的性能。

我们使用混合模式做一个简单的loading：

```kotlin
    private val mBitmap = BitmapFactory.decodeResource(resources, R.mipmap.loading)
    private val mXfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_IN)  //SRC_IN混合模式
    private val mPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        isFilterBitmap = true //双线性过滤
        color = Color.parseColor("#ff7400")
    }

    private val mSrcRect = Rect(0,0,mBitmap.width,mBitmap.height)
    private val mDestRect = RectF(0f,0f,mBitmap.width.toFloat(),mBitmap.height.toFloat())
    private val mDynamicRect = RectF(0f,mBitmap.height.toFloat(),mBitmap.width.toFloat(),mBitmap.height.toFloat())
    private var mTotalWidth = 0
    private var mTotalHeight = 0
    private var mCurrentTop = mBitmap.height.toFloat() //矩形当前高度

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec)
        setMeasuredDimension(mBitmap.width+20,mBitmap.height+20)
    }
    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        super.onSizeChanged(w, h, oldw, oldh)
        mTotalWidth = w
        mTotalHeight = h
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        //存为新图层
        val saveCount = canvas.saveLayer(0f, 0f, mTotalWidth.toFloat(), mTotalHeight.toFloat(), mPaint)
        //绘制目标图
        canvas.drawBitmap(mBitmap,mSrcRect,mDestRect,mPaint)
        //设置混合模式
        mPaint.setXfermode(mXfermode)
        //绘制源图
        canvas.drawRect(mDynamicRect,mPaint)
        //清除混合模式
        mPaint.setXfermode(null)
        //恢复图层
        canvas.restoreToCount(saveCount)

        mCurrentTop -= 1
        if (mCurrentTop <= 0) {
            //从底往上循环
            mCurrentTop = mBitmap.height.toFloat()
        }
        mDynamicRect.top = mCurrentTop
        postInvalidate()
    }
```

效果如下：

![PoterDuffLoading](https://ForLovelj.github.io/img/PoterDuffLoading.gif)
 
利用 `Xfermode` 可以实现很多效果，例如橡皮擦效果等，看大家脑洞了。

### 设置基本颜色 setColor(int color)

方法名和使用方法都非常简单直接：

```kotlin
    mPaint.strokeWidth = 40f
    mPaint.color = Color.RED
    canvas.drawLine(100f,100f,800f,100f,mPaint)

    mPaint.color = Color.parseColor("#FF9300")
    canvas.drawLine(100f,200f,800f,200f,mPaint)

    mPaint.color = Color.BLUE
    canvas.drawLine(100f,300f,800f,300f,mPaint)
```

![setColor](https://ForLovelj.github.io/img/setColor.png)

### 设置基本颜色 setARGB(int a, int r, int g, int b)

```kotlin
    mPaint.strokeWidth = 40f
    mPaint.setARGB(100,255,0,0)
    canvas.drawLine(100f,100f,800f,100f,mPaint)

    mPaint.setARGB(100,0,255,0)
    canvas.drawLine(100f,200f,800f,200f,mPaint)

    mPaint.setARGB(255,0,0,255)
    canvas.drawLine(100f,300f,800f,300f,mPaint)
```

![setARGB](https://ForLovelj.github.io/img/setARGB.png)

### 设置着色器 setShader(Shader shader)

除了直接设置颜色， `Paint` 还可以使用 `Shader` 。

`Shader` 的中文叫做「着色器」，也是用于设置绘制颜色的。「着色器」不是 `Android` 独有的，它是图形领域里一个通用的概念，它和直接设置颜色的区别是，着色器设置的是一个颜色方案，或者说是一套着色规则。当设置了 `Shader` 之后，`Paint` 在绘制图形和文字时就不使用 `setColor/ARGB()` 设置的颜色了，而是使用 `Shader` 的方案中的颜色。

在 `Android` 的绘制里使用 `Shader` ，并不直接用 `Shader` 这个类，而是用它的几个子类。具体来讲有 `LinearGradient` `RadialGradient` `SweepGradient` `BitmapShader` `ComposeShader` 这么几个：

#### 线性渐变 LinearGradient

设置两个点和两种颜色，以这两个点作为端点，使用两种颜色的渐变来绘制颜色。

构造方法：

```java
    /**
     * @param x0       渐变线开始的x坐标
     * @param y0       渐变线开始的y坐标
     * @param x1       渐变线结束的x坐标
     * @param y1       渐变线结束的y坐标
     * @param color0   渐变开始的颜色
     * @param color1   渐变结束的颜色
     * @param tile     渐变开始和结束点范围之外的着色规则
     */
    public LinearGradient(float x0, float y0, float x1, float y1,int color0, int color1,TileMode tile)

    /**
     * @param x0       渐变线开始的x坐标
     * @param y0       渐变线开始的y坐标
     * @param x1       渐变线结束的x坐标
     * @param y1       渐变线结束的y坐标
     * @param colors   颜色数组
     * @param positions    颜色数组中每个颜色对应的相对位置，取值范围(0~1)，positions数组元素的个数一定colors数组的个数相同如果为null，则沿渐变线均匀分布
     * @param tile         渐变开始和结束点范围之外的着色规则
     */
    public LinearGradient(float x0, float y0, float x1, float y1, @NonNull int[] colors,@Nullable float[] positions, @NonNull TileMode tile)

    ...
```

第一种构造方法演示：

```kotlin
    //CLAMP 渐变开始和结束点范围之外 用相邻位置的颜色填充
    val shader = LinearGradient(100f,100f,500f,200f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.CLAMP)
    mPaint.shader = shader
    canvas.drawRect(100f,100f,900f,200f,mPaint)

    //MIRROR    镜像填充
    val shader1 = LinearGradient(100f,300f,500f,400f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.MIRROR)
    mPaint.shader = shader1
    canvas.drawRect(100f,300f,900f,400f,mPaint)

    //REPEAT    重复填充
    val shader2 = LinearGradient(100f,500f,500f,600f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.REPEAT)
    mPaint.shader = shader2
    canvas.drawRect(100f,500f,900f,600f,mPaint)

    //DECAL api >= 31 仅填充渐变开始和结束点范围。如果超出其原始边界，则绘制透明黑色。
    val shader3 = LinearGradient(100f,700f,500f,800f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.DECAL)
    mPaint.shader = shader3
    canvas.drawRect(100f,700f,900f,800f,mPaint)
```

![LinearGradient](https://ForLovelj.github.io/img/LinearGradient.png)

我们用第二种构造方法做一个文字效果：

```kotlin

    private var mTextPaint: TextPaint? = null
    private lateinit var mLinearGradient: LinearGradient
    private var deltax = 20
    private var mTranslate = 0f
    private val mMatrix = Matrix()

    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        super.onSizeChanged(w, h, oldw, oldh)

        //拿到TextView的paint
        mTextPaint = paint
        val text = text.toString()
        //测量文本宽度
        val textWidth = mTextPaint!!.measureText(text)
        val gradientSize = textWidth/text.length * 3

        //从左边-gradientSize开始，即左边距离文字gradientSize开始渐变
        mLinearGradient = LinearGradient(-gradientSize,0f,0f,0f, intArrayOf(0x22ffffff,
            0xffffffff.toInt(), 0x22ffffff),null,Shader.TileMode.CLAMP)
        mTextPaint!!.shader = mLinearGradient
    }

    override fun onDraw(canvas: Canvas?) {
        super.onDraw(canvas)
        mTranslate += deltax
        val textWidth = mTextPaint!!.measureText(text.toString())
        if (mTranslate > textWidth + 1 || mTranslate < 1) {
            //先从前往后渐变 再从后往前
            deltax = -deltax
        }
        mMatrix.reset()
        mMatrix.setTranslate(mTranslate,0f)
        mLinearGradient.setLocalMatrix(mMatrix)
        postInvalidateDelayed(50)
    }
```

![LinearGradient2](https://ForLovelj.github.io/img/LinearGradient2.gif)

#### 辐射渐变 RadialGradient

辐射渐变很好理解，就是从中心向周围辐射状的渐变。

构造方法：

```java
    /**
     * @param centerX     辐射中心的x坐标
     * @param centerY     辐射中心的y坐标
     * @param radius      辐射半径
     * @param centerColor 辐射中心的颜色
     * @param edgeColor   辐射边缘的颜色
     * @param tileMode    辐射范围之外的着色模式
     */
    public RadialGradient(float centerX, float centerY, float radius,
            @ColorInt int centerColor, @ColorInt int edgeColor, @NonNull TileMode tileMode)

    ...
```

示例：
```kotlin
    //CLAMP
    val shader = RadialGradient(300f,300f,150f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.CLAMP)
    mPaint.shader = shader
    canvas.drawCircle(300f,300f,150f,mPaint)

    //MIRROR
    val shader1 = RadialGradient(300f,600f,50f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.MIRROR)
    mPaint.shader = shader1
    canvas.drawCircle(300f,600f,150f,mPaint)

    //REPEAT
    val shader2 = RadialGradient(300f,900f,50f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.REPEAT)
    mPaint.shader = shader2
    canvas.drawCircle(300f,900f,150f,mPaint)

    //DECAL
    val shader3 = RadialGradient(300f,1200f,50f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.DECAL)
    mPaint.shader = shader3
    canvas.drawCircle(300f,1200f,150f,mPaint)
```

![RadialGradient](https://ForLovelj.github.io/img/RadialGradient.png)

#### 扫描渐变 SweepGradient

构造方法：

```java
    /**
     * @param cx       扫描的中心x坐标
     * @param cy       扫描的中心y坐标
     * @param color0   扫描的起始颜色
     * @param color1   扫描的终止颜色
     */
    public SweepGradient(float cx, float cy, @ColorInt int color0, @ColorInt int color1)

    ...
```

示例：

```kotlin
    val shader = SweepGradient(300f,300f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"))
    mPaint.shader = shader
    canvas.drawCircle(300f,300f,200f,mPaint)
```
![SweepGradient](https://ForLovelj.github.io/img/SweepGradient.png)

#### BitmapShader

用 `Bitmap` 来着色，其实也就是用 `Bitmap` 的像素来作为图形或文字的填充.

```kotlin
    val bitmap = BitmapFactory.decodeResource(resources, R.mipmap.beauty1)
    //CLAMP 当所画图形的尺寸大于bitmap的尺寸，会用bitmap和剩余空间相邻位置的颜色填充剩余空间
    //当所画图形的尺寸小于bitmap的尺寸，会对bitmap进行裁剪，利用这个原理，我们可以去制造圆形头像
    val shader = BitmapShader(bitmap,Shader.TileMode.CLAMP,Shader.TileMode.CLAMP)
    mPaint.shader = shader
    canvas.drawCircle(400f,400f,300f,mPaint)

    //另外几种填充方式和之前渐变一样，这儿不再赘述
//        val shader = BitmapShader(bitmap,Shader.TileMode.MIRROR,Shader.TileMode.MIRROR)
//        canvas.drawRect(0f,0f,canvas.width.toFloat(),canvas.height.toFloat(),mPaint)
```

![BitmapShader](https://ForLovelj.github.io/img/BitmapShader.png)

#### 组合着色器 ComposeShader

构造方法：

```java
    /**
     * @param shaderA  目标shader
     * @param shaderB  源shader
     * @param mode     两个Shader的PorterDuff结合模式，即shaderA和shaderB应该怎样共同绘制
     *
     */
    public ComposeShader(@NonNull Shader shaderA, @NonNull Shader shaderB,
            @NonNull PorterDuff.Mode mode)


    /**
     * 需要api >= 29
     * @param shaderA  目标shader
     * @param shaderB  源shader
     * @param blendMode 两个Shader的BlendMode结合模式，即shaderA和shaderB应该怎样共同绘制
    */
    public ComposeShader(@NonNull Shader shaderA, @NonNull Shader shaderB,
            @NonNull BlendMode blendMode)
```

`shaderA` 和 `shaderB` 参数都很简单， `PorterDuff.Mode`我们在上面已经讲过了，这儿不再赘述。

> 注意：ComposeShader 内部想使用**相同类型的着色器**（比如说使用两个BitmapShader混合）需要api26以上才支持硬件加速功能，如果api26以下需要关闭硬件加速才能看到效果。使用不同的着色器不影响。

示例：

```kotlin
    val bitmap = BitmapFactory.decodeResource(resources, R.mipmap.beauty1)
    //第一个bitmapShader
    val bitmapShader = BitmapShader(bitmap,Shader.TileMode.CLAMP,Shader.TileMode.CLAMP)
    //第二个辐射渐变shader
    val radialShader = RadialGradient(400f,300f,100f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.CLAMP)
    // ComposeShader：结合两个 Shader
    val shader = ComposeShader(bitmapShader,radialShader,PorterDuff.Mode.MULTIPLY)

    mPaint.shader = shader
    canvas.drawCircle(400f,400f,300f,mPaint)
```

![ComposeShader](https://ForLovelj.github.io/img/ComposeShader.png)

### setColorFilter(ColorFilter colorFilter)



