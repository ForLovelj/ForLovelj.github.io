---
layout: post
title: 04-Paint详解
author: clow
date: 2021-04-10 21:10:10
categories:
- Android
tags: 自定义View
---

# 一、前言
在上一节《Canvas绘图基础详解》我们说到Canvas绘图有三个基本要素：`Canvas`、`绘图坐标系`以及`Paint`，上一节我们详细介绍了`Canvas`和`绘图坐标系`的使用。这一节我们就来详细讲讲`Paint`的一些使用方式。`Paint`就是画笔的意思，用于设置绘制风格，如:线宽(笔触粗细)、颜色、透明度和填充风格等等。

## 二、常用api

- setFlags(@PaintFlag int flags): //添加标识，用以实现特定的效果
- setColor(int color): 设置绘制的颜色，使用颜色值来表示，该颜色值包括透明度和RGB颜色。
- setARGB(int a,int r,int g,int b): 设置绘制的颜色，a代表透明度，r，g，b代表颜色值。
- setAlpha(int a): 设置绘制图形的透明度。
- setAntiAlias(boolean aa): 设置是否使用抗锯齿功能，会消耗较大资源，绘制图形速度会变慢。
- setDither(boolean dither): 设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰
- setStyle(Paint.Style style)： 设置画笔的样式，为FILL，FILL_AND_STROKE，或STROKE
- setStrokeWidth(float width)： 当画笔样式为STROKE或FILL_AND_STROKE时，设置笔刷的粗细度
- setStrokeCap(Paint.Cap cap)： 当画笔样式为STROKE或FILL_AND_STROKE时，设置线头的形状， 如圆形样Cap.ROUND,或方形样式Cap.SQUARE
-  setStrokeJoin(Paint.Join join)： 设置结合处的样子，Miter:结合处为锐角， Round:结合处为圆弧：BEVEL：结合处为直线
- setStrokeMiter(float miter)：它用于设置 MITER 型拐角的延长线的最大值。
- setXfermode(Xfermode xfermode)： 设置图形重叠时的处理方式，如合并，取交集或并集，经常用来制作橡皮的擦除效果
- setFilterBitmap(boolean filter)： 如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作， 加快显示速度，本设置项依赖于dither和xfermode的设置
- setMaskFilter(MaskFilter maskfilter)： 设置MaskFilter，可以用不同的MaskFilter实现滤镜的效果，如滤化，立体等
- setColorFilter(ColorFilter colorfilter)： 设置颜色过滤器，可以在绘制颜色时实现不用颜色的变换效果
- setPathEffect(PathEffect effect) 设置绘制路径的效果，如点画线等
- setShader(Shader shader)： 设置图像效果，使用Shader可以绘制出各种渐变效果
- setShadowLayer(float radius ,float dx,float dy,int color)：在图形下面设置阴影层，产生阴影效果， radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色

- setFakeBoldText(boolean fakeBoldText)： 模拟实现粗体文字，设置在小字体上效果会非常差
- etSubpixelText(boolean subpixelText)： 设置该项为true，将有助于文本在LCD屏幕上的显示效果
- setTextAlign(Paint.Align align)： 设置绘制文字的对齐方向
- setTextScaleX(float scaleX)： 设置绘制文字x轴的缩放比例，可以实现文字的拉伸的效果
- setLetterSpacing(float letterSpacing): 设置字符间的间距
- setTextSize(float textSize)： 设置绘制文字的字号大小
- setTextSkewX(float skewX)： 设置斜体文字，skewX为倾斜弧度
- setTypeface(Typeface typeface)： 设置Typeface对象，即字体风格，包括粗体，斜体以及衬线体，非衬线体等
- setUnderlineText(boolean underlineText)： 设置带有下划线的文字效果
- setStrikeThruText(boolean strikeThruText)： 设置带有删除线的效果

- float ascent( )：测量baseline之上至字符最高处的距离
- float descent()：baseline之下至字符最低处的距离
- int breakText(char[] text, int index, int count, float maxWidth, float[] measuredWidth)： 检测一行显示多少文字
- clearShadowLayer( )：清除阴影层
- ...

## 三、用例测试

### setFlags(int flags)

常用的flag有如下几种：
``` java
    Paint.ANTI_ALIAS_FLAG   //抗锯齿标志
    Paint.FILTER_BITMAP_FLAG    //使位图双线性过滤的标志
    Paint.DITHER_FLAG   //有利抖动
    Paint.UNDERLINE_TEXT_FLAG   //下划线
    Paint.STRIKE_THRU_TEXT_FLAG //删除线
    Paint.FAKE_BOLD_TEXT_FLAG   //加粗
    Paint.LINEAR_TEXT_FLAG  //文本平滑线性缩放
    Paint.SUBPIXEL_TEXT_FLAG    //文本的亚像素定位标志
    Paint.EMBEDDED_BITMAP_TEXT_FLAG //允许在绘制文本时使用位图字体
```
举个栗子：

设置抗锯齿 `mPaint.setFlags(Paint.ANTI_ALIAS_FLAG)`  它等价于 `mPaint.setAntiAlias(true)`。

设置多个flag `mPaint.setFlags(Paint.ANTI_ALIAS_FLAG | Paint.UNDERLINE_TEXT_FLAG)` 同时设置抗锯齿和下划线。

### 设置抗锯齿setAntiAlias(boolean aa)

抗锯齿是指在图像中，物体边缘总会或多或少的呈现三角形的锯齿，而抗锯齿就是指对图像边缘进行柔化处理，使图像边缘看起来更平滑，更接近实物的物体。

- true：柔化处理
- false：不柔化处理

![抗锯齿](https://ForLovelj.github.io/img/抗锯齿.png)

### 设置防抖动setDither(boolean dither)

这个api现在用的不多了，因为现在的 `Android` 版本的绘制，默认的色彩深度已经是 `32` 位的 `ARGB_8888` ，效果已经足够清晰了。只有当你向自建的 `Bitmap` 中绘制，并且选择 `16` 位色的 `ARGB_4444` 或者 `RGB_565` 的时候，开启它才会有比较明显的效果。

引用wiki的一张图来展示它的效果：

![防抖动](https://ForLovelj.github.io/img/防抖动.png)

### 设置Paint的样式 setStyle(Paint.Style style)

画笔样式有三种，默认是`Paint.Style.FILL`模式：

- Paint.Style.FILL：填充内部（例如这种模式画一个圆圆内部颜色是被填充的）
- Paint.Style.STROKE ：描边（内部不被填充，可以用来绘制圆环）
- Paint.Style.FILL_AND_STROKE ：填充内部和描边（展示效果和FILL看起来是一样的）

``` kotlin
    mPaint.style = Paint.Style.FILL //设置填充模式
    canvas.drawCircle(200f,300f,100f,mPaint)
    
    mPaint.style = Paint.Style.STROKE   //设置描边模式
    canvas.drawCircle(500f,300f,100f,mPaint)
    
    mPaint.style = Paint.Style.FILL_AND_STROKE  //设置描边加填充模式
    canvas.drawCircle(800f,300f,100f,mPaint)
```

![setStyle](https://ForLovelj.github.io/img/setStyle.png)

### 设置画笔的粗细 setStrokeWidth(float width)

设置线条的宽度，单位为像素，默认值是 0。

``` kotlin
    mPaint.style = Paint.Style.STROKE   //设置描边模式

    mPaint.strokeWidth = 1f
    canvas.drawCircle(200f,300f,100f,mPaint)

    mPaint.strokeWidth = 10f
    canvas.drawCircle(500f,300f,100f,mPaint)

    mPaint.strokeWidth = 40f
    canvas.drawCircle(800f,300f,100f,mPaint)
```

![setStrokeWidth](https://ForLovelj.github.io/img/setStrokeWidth.png)

> 线条宽度 0 和 1 的区别<br>
默认情况下，线条宽度为 0，但你会发现，这个时候它依然能够画出线，线条的宽度为 1 像素。那么它和线条宽度为 1 有什么区别呢？<br>
其实这个和「几何变换」有关：你可以为 `Canvas` 设置 `Matrix` 来实现几何变换（如放大、缩小、平移、旋转），在几何变换之后 Canvas 绘制的内容就会发生相应变化，包括线条也会加粗，例如 `2` 像素宽度的线条在 Canvas 放大 `2` 倍后会被以 `4` 像素宽度来绘制。而当线条宽度被设置为 `0` 时，它的宽度就被固定为 `1` 像素，就算 `Canvas` 通过几何变换被放大，它也依然会被以 `1` 像素宽度来绘制。`Google` 在文档中把线条宽度为 `0` 时称作「hairline mode（发际线模式）」。

### 设置线头的形状setStrokeCap(Paint.Cap cap)

线头形状有三种，默认为 `Paint.Cap.BUTT` :

- Paint.Cap.BUTT:   平头
- Paint.Cap.ROUND:  圆头
- Paint.Cap.SQUARE: 方头

当线条的宽度是 1 像素时，这三种线头的表现是完全一致的，全是 1 个像素的点；而当线条变粗的时候，它们就会表现出不同的样子：

``` kotlin
    mPaint.strokeWidth = 40f
    mPaint.strokeCap = Paint.Cap.BUTT
    canvas.drawLine(100f,100f,800f,100f,mPaint)

    mPaint.strokeCap = Paint.Cap.ROUND
    canvas.drawLine(100f,200f,800f,200f,mPaint)

    mPaint.strokeCap = Paint.Cap.SQUARE
    canvas.drawLine(100f,300f,800f,300f,mPaint)
```

![setStrokeCap](https://ForLovelj.github.io/img/setStrokeCap.png)

图上的红色直线是额外加上便于理解的，有了红线作为辅助，可以清晰的看出线的三种线头的区别。

### 设置拐角的形状setStrokeJoin(Paint.Join join)

拐角形状有三种，默认为 `Paint.Join.MITER` :

- Paint.Join.MITER：尖角
- Paint.Join.BEVEL：平角
- Paint.Join.ROUND：圆角

``` kotlin
    mPaint.style = Paint.Style.STROKE
    mPaint.strokeWidth = 40f
    //画一个三角形
    val path = Path().apply {
        moveTo(100f,100f)
        lineTo(400f,100f)
        lineTo(400f,300f)
        close()
    }

    mPaint.strokeJoin = Paint.Join.MITER    //尖角
    canvas.drawPath(path,mPaint)

    canvas.translate(0f,300f)
    mPaint.strokeJoin = Paint.Join.BEVEL    //平角
    canvas.drawPath(path,mPaint)

    canvas.translate(0f,300f)
    mPaint.strokeJoin = Paint.Join.ROUND    //圆角
    canvas.drawPath(path,mPaint)
```

![setStrokeJoin](https://ForLovelj.github.io/img/setStrokeJoin.png)

### setStrokeMiter(float miter)

这个方法是对于 `setStrokeJoin()` 的一个补充，它用于设置 `MITER` 型拐角的延长线的最大值。所谓「延长线的最大值」，是这么一回事：

当线条拐角为 `MITER` 时，拐角处的外缘需要使用延长线来补偿：

![setStrokeMiter1](https://ForLovelj.github.io/img/setStrokeMiter1.png)

而这种补偿方案会有一个问题：如果拐角的角度太小，就有可能由于出现连接点过长的情况。比如这样：

![setStrokeMiter2](https://ForLovelj.github.io/img/setStrokeMiter2.png)

所以为了避免意料之外的过长的尖角出现， `MITER` 型连接点有一个额外的规则：当尖角过长时，自动改用 `BEVEL` 的方式来渲染连接点。例如上图的这个尖角，在默认情况下是不会出现的，而是会由于延长线过长而被转为 `BEVEL` 型连接点：

![setStrokeMiter3](https://ForLovelj.github.io/img/setStrokeMiter3.png)

`setStrokeMiter(miter)` 方法中 `miter` 参数是对于转角长度的限制，具体来讲，是指尖角的外缘端点和内部拐角的距离与线条宽度的比:

![setStrokeMiter4](https://ForLovelj.github.io/img/setStrokeMiter4.png)

用几何知识很容易得出这个比值的计算公式：如果拐角的大小为 θ ，那么这个比值就等于 1/sin(θ/2) 。

这个 miter limit 的默认值是 4，对应的是一个大约 29° 的锐，默认情况下，大于这个角的尖角会被保留，而小于这个夹角的就会被「削成平头」。

```kotlin
    mPaint.style = Paint.Style.STROKE
    mPaint.strokeWidth = 40f

    //画一个等边直角三角形
    val path = Path().apply {
        moveTo(100f,100f)
        lineTo(300f,100f)
        lineTo(100f,300f)
        close()
    }
    //1度=π/180≈0.01745弧度，1弧度=180/π≈57.3度
    mPaint.strokeMiter = (1 / sin(20 * Math.PI/180)).toFloat()  //大于这个40°的尖角会被保留，小于的就被削成平头
    canvas.drawPath(path,mPaint)

    canvas.translate(0f,300f)
    mPaint.strokeMiter = (1/sin(30 * Math.PI/180)).toFloat()    //大于这个60°的尖角会被保留，小于的就被削成平头
    canvas.drawPath(path,mPaint)

    canvas.translate(0f,300f)
    mPaint.strokeMiter = (1/sin(60*Math.PI/180)).toFloat()  //大于这个120°的尖角会被保留，小于的就被削成平头
    canvas.drawPath(path,mPaint)
```

![setStrokeMiter](https://ForLovelj.github.io/img/setStrokeMiter.png)


