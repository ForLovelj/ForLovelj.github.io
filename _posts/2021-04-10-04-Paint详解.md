---
layout: post
title: 04-Paint详解
author: clow
date: 2021-04-10 21:10:10
categories:
- Android
tags: 自定义View
---

# 一、前言
在上一节《Canvas绘图基础详解》我们说到Canvas绘图有三个基本要素：`Canvas`、`绘图坐标系`以及`Paint`，上一节我们详细介绍了`Canvas`和`绘图坐标系`的使用。这一节我们就来详细讲讲`Paint`的一些使用方式。`Paint`就是画笔的意思，用于设置绘制风格，如:线宽(笔触粗细)、颜色、透明度和填充风格等等。

## 二、常用api

- setFlags(@PaintFlag int flags): //添加标识，用以实现特定的效果
- setColor(int color): 设置绘制的颜色，使用颜色值来表示，该颜色值包括透明度和RGB颜色。
- setARGB(int a,int r,int g,int b): 设置绘制的颜色，a代表透明度，r，g，b代表颜色值。
- setAlpha(int a): 设置绘制图形的透明度。
- setAntiAlias(boolean aa): 设置是否使用抗锯齿功能，会消耗较大资源，绘制图形速度会变慢。
- setDither(boolean dither): 设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰
- setStyle(Paint.Style style)： 设置画笔的样式，为FILL，FILL_AND_STROKE，或STROKE
- setStrokeWidth(float width)： 当画笔样式为STROKE或FILL_AND_STROKE时，设置笔刷的粗细度
- setStrokeCap(Paint.Cap cap)： 当画笔样式为STROKE或FILL_AND_STROKE时，设置线头的形状， 如圆形样Cap.ROUND,或方形样式Cap.SQUARE
-  setStrokeJoin(Paint.Join join)： 设置结合处的样子，Miter:结合处为锐角， Round:结合处为圆弧：BEVEL：结合处为直线
- setStrokeMiter(float miter)：它用于设置 MITER 型拐角的延长线的最大值。
- setXfermode(Xfermode xfermode)： 设置图形重叠时的处理方式，如合并，取交集或并集，经常用来制作橡皮的擦除效果
- setFilterBitmap(boolean filter)： 如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作， 加快显示速度，本设置项依赖于dither和xfermode的设置
- setMaskFilter(MaskFilter maskfilter)： 设置MaskFilter，可以用不同的MaskFilter实现滤镜的效果，如滤化，立体等
- setColorFilter(ColorFilter colorfilter)： 设置颜色过滤器，可以在绘制颜色时实现不用颜色的变换效果
- setPathEffect(PathEffect effect) 设置绘制路径的效果，如点画线等
- setShader(Shader shader)： 设置图像效果，使用Shader可以绘制出各种渐变效果
- setShadowLayer(float radius ,float dx,float dy,int color)：在图形下面设置阴影层，产生阴影效果， radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色

- setFakeBoldText(boolean fakeBoldText)： 模拟实现粗体文字，设置在小字体上效果会非常差
- etSubpixelText(boolean subpixelText)： 设置该项为true，将有助于文本在LCD屏幕上的显示效果
- setTextAlign(Paint.Align align)： 设置绘制文字的对齐方向
- setTextScaleX(float scaleX)： 设置绘制文字x轴的缩放比例，可以实现文字的拉伸的效果
- setLetterSpacing(float letterSpacing): 设置字符间的间距
- setTextSize(float textSize)： 设置绘制文字的字号大小
- setTextSkewX(float skewX)： 设置斜体文字，skewX为倾斜弧度
- setTypeface(Typeface typeface)： 设置Typeface对象，即字体风格，包括粗体，斜体以及衬线体，非衬线体等
- setUnderlineText(boolean underlineText)： 设置带有下划线的文字效果
- setStrikeThruText(boolean strikeThruText)： 设置带有删除线的效果

- float ascent( )：测量baseline之上至字符最高处的距离
- float descent()：baseline之下至字符最低处的距离
- int breakText(char[] text, int index, int count, float maxWidth, float[] measuredWidth)： 检测一行显示多少文字
- clearShadowLayer( )：清除阴影层
- ...

## 三、用例测试

### setFlags(int flags)

常用的flag有如下几种：
``` java
    Paint.ANTI_ALIAS_FLAG   //抗锯齿标志
    Paint.FILTER_BITMAP_FLAG    //使位图双线性过滤的标志
    Paint.DITHER_FLAG   //有利抖动
    Paint.UNDERLINE_TEXT_FLAG   //下划线
    Paint.STRIKE_THRU_TEXT_FLAG //删除线
    Paint.FAKE_BOLD_TEXT_FLAG   //加粗
    Paint.LINEAR_TEXT_FLAG  //文本平滑线性缩放
    Paint.SUBPIXEL_TEXT_FLAG    //文本的亚像素定位标志
    Paint.EMBEDDED_BITMAP_TEXT_FLAG //允许在绘制文本时使用位图字体
```
举个栗子：

设置抗锯齿 `mPaint.setFlags(Paint.ANTI_ALIAS_FLAG)`  它等价于 `mPaint.setAntiAlias(true)`。

设置多个flag `mPaint.setFlags(Paint.ANTI_ALIAS_FLAG | Paint.UNDERLINE_TEXT_FLAG)` 同时设置抗锯齿和下划线。

### 设置抗锯齿 setAntiAlias(boolean aa)

抗锯齿是指在图像中，物体边缘总会或多或少的呈现三角形的锯齿，而抗锯齿就是指对图像边缘进行柔化处理，使图像边缘看起来更平滑，更接近实物的物体。

- true：柔化处理
- false：不柔化处理

![抗锯齿](https://ForLovelj.github.io/img/抗锯齿.png)

### 设置防抖动 setDither(boolean dither)

这个api现在用的不多了，因为现在的 `Android` 版本的绘制，默认的色彩深度已经是 `32` 位的 `ARGB_8888` ，效果已经足够清晰了。只有当你向自建的 `Bitmap` 中绘制，并且选择 `16` 位色的 `ARGB_4444` 或者 `RGB_565` 的时候，开启它才会有比较明显的效果。

引用wiki的一张图来展示它的效果：

![防抖动](https://ForLovelj.github.io/img/防抖动.png)

### 设置Paint的样式 setStyle(Paint.Style style)

画笔样式有三种，默认是`Paint.Style.FILL`模式：

- Paint.Style.FILL：填充内部（例如这种模式画一个圆圆内部颜色是被填充的）
- Paint.Style.STROKE ：描边（内部不被填充，可以用来绘制圆环）
- Paint.Style.FILL_AND_STROKE ：填充内部和描边（展示效果和FILL看起来是一样的）

``` kotlin
    mPaint.style = Paint.Style.FILL //设置填充模式
    canvas.drawCircle(200f,300f,100f,mPaint)
    
    mPaint.style = Paint.Style.STROKE   //设置描边模式
    canvas.drawCircle(500f,300f,100f,mPaint)
    
    mPaint.style = Paint.Style.FILL_AND_STROKE  //设置描边加填充模式
    canvas.drawCircle(800f,300f,100f,mPaint)
```

![setStyle](https://ForLovelj.github.io/img/setStyle.png)

### 设置画笔的粗细 setStrokeWidth(float width)

设置线条的宽度，单位为像素，默认值是 0。

``` kotlin
    mPaint.style = Paint.Style.STROKE   //设置描边模式

    mPaint.strokeWidth = 1f
    canvas.drawCircle(200f,300f,100f,mPaint)

    mPaint.strokeWidth = 10f
    canvas.drawCircle(500f,300f,100f,mPaint)

    mPaint.strokeWidth = 40f
    canvas.drawCircle(800f,300f,100f,mPaint)
```

![setStrokeWidth](https://ForLovelj.github.io/img/setStrokeWidth.png)

> 线条宽度 0 和 1 的区别<br>
默认情况下，线条宽度为 0，但你会发现，这个时候它依然能够画出线，线条的宽度为 1 像素。那么它和线条宽度为 1 有什么区别呢？<br>
其实这个和「几何变换」有关：你可以为 `Canvas` 设置 `Matrix` 来实现几何变换（如放大、缩小、平移、旋转），在几何变换之后 Canvas 绘制的内容就会发生相应变化，包括线条也会加粗，例如 `2` 像素宽度的线条在 Canvas 放大 `2` 倍后会被以 `4` 像素宽度来绘制。而当线条宽度被设置为 `0` 时，它的宽度就被固定为 `1` 像素，就算 `Canvas` 通过几何变换被放大，它也依然会被以 `1` 像素宽度来绘制。`Google` 在文档中把线条宽度为 `0` 时称作「hairline mode（发际线模式）」。

### 设置线头的形状 setStrokeCap(Paint.Cap cap)

线头形状有三种，默认为 `Paint.Cap.BUTT` :

- Paint.Cap.BUTT:   平头
- Paint.Cap.ROUND:  圆头
- Paint.Cap.SQUARE: 方头

当线条的宽度是 1 像素时，这三种线头的表现是完全一致的，全是 1 个像素的点；而当线条变粗的时候，它们就会表现出不同的样子：

``` kotlin
    mPaint.strokeWidth = 40f
    mPaint.strokeCap = Paint.Cap.BUTT
    canvas.drawLine(100f,100f,800f,100f,mPaint)

    mPaint.strokeCap = Paint.Cap.ROUND
    canvas.drawLine(100f,200f,800f,200f,mPaint)

    mPaint.strokeCap = Paint.Cap.SQUARE
    canvas.drawLine(100f,300f,800f,300f,mPaint)
```

![setStrokeCap](https://ForLovelj.github.io/img/setStrokeCap.png)

图上的红色直线是额外加上便于理解的，有了红线作为辅助，可以清晰的看出线的三种线头的区别。

### 设置拐角的形状 setStrokeJoin(Paint.Join join)

拐角形状有三种，默认为 `Paint.Join.MITER` :

- Paint.Join.MITER：尖角
- Paint.Join.BEVEL：平角
- Paint.Join.ROUND：圆角

``` kotlin
    mPaint.style = Paint.Style.STROKE
    mPaint.strokeWidth = 40f
    //画一个三角形
    val path = Path().apply {
        moveTo(100f,100f)
        lineTo(400f,100f)
        lineTo(400f,300f)
        close()
    }

    mPaint.strokeJoin = Paint.Join.MITER    //尖角
    canvas.drawPath(path,mPaint)

    canvas.translate(0f,300f)
    mPaint.strokeJoin = Paint.Join.BEVEL    //平角
    canvas.drawPath(path,mPaint)

    canvas.translate(0f,300f)
    mPaint.strokeJoin = Paint.Join.ROUND    //圆角
    canvas.drawPath(path,mPaint)
```

![setStrokeJoin](https://ForLovelj.github.io/img/setStrokeJoin.png)

### setStrokeMiter(float miter)

这个方法是对于 `setStrokeJoin()` 的一个补充，它用于设置 `MITER` 型拐角的延长线的最大值。所谓「延长线的最大值」，是这么一回事：

当线条拐角为 `MITER` 时，拐角处的外缘需要使用延长线来补偿：

![setStrokeMiter1](https://ForLovelj.github.io/img/setStrokeMiter1.png)

而这种补偿方案会有一个问题：如果拐角的角度太小，就有可能由于出现连接点过长的情况。比如这样：

![setStrokeMiter2](https://ForLovelj.github.io/img/setStrokeMiter2.png)

所以为了避免意料之外的过长的尖角出现， `MITER` 型连接点有一个额外的规则：当尖角过长时，自动改用 `BEVEL` 的方式来渲染连接点。例如上图的这个尖角，在默认情况下是不会出现的，而是会由于延长线过长而被转为 `BEVEL` 型连接点：

![setStrokeMiter3](https://ForLovelj.github.io/img/setStrokeMiter3.png)

`setStrokeMiter(miter)` 方法中 `miter` 参数是对于转角长度的限制，具体来讲，是指尖角的外缘端点和内部拐角的距离与线条宽度的比:

![setStrokeMiter4](https://ForLovelj.github.io/img/setStrokeMiter4.png)

用几何知识很容易得出这个比值的计算公式：如果拐角的大小为 θ ，那么这个比值就等于 1/sin(θ/2) 。

这个 miter limit 的默认值是 4，对应的是一个大约 29° 的锐，默认情况下，大于这个角的尖角会被保留，而小于这个夹角的就会被「削成平头」。

```kotlin
    mPaint.style = Paint.Style.STROKE
    mPaint.strokeWidth = 40f

    //画一个等边直角三角形
    val path = Path().apply {
        moveTo(100f,100f)
        lineTo(300f,100f)
        lineTo(100f,300f)
        close()
    }
    //1度=π/180≈0.01745弧度，1弧度=180/π≈57.3度
    mPaint.strokeMiter = (1 / sin(20 * Math.PI/180)).toFloat()  //大于这个40°的尖角会被保留，小于的就被削成平头
    canvas.drawPath(path,mPaint)

    canvas.translate(0f,300f)
    mPaint.strokeMiter = (1/sin(30 * Math.PI/180)).toFloat()    //大于这个60°的尖角会被保留，小于的就被削成平头
    canvas.drawPath(path,mPaint)

    canvas.translate(0f,300f)
    mPaint.strokeMiter = (1/sin(60*Math.PI/180)).toFloat()  //大于这个120°的尖角会被保留，小于的就被削成平头
    canvas.drawPath(path,mPaint)
```

![setStrokeMiter](https://ForLovelj.github.io/img/setStrokeMiter.png)

### 设置基本颜色 setColor(int color)

方法名和使用方法都非常简单直接：

```kotlin
    mPaint.strokeWidth = 40f
    mPaint.color = Color.RED
    canvas.drawLine(100f,100f,800f,100f,mPaint)

    mPaint.color = Color.parseColor("#FF9300")
    canvas.drawLine(100f,200f,800f,200f,mPaint)

    mPaint.color = Color.BLUE
    canvas.drawLine(100f,300f,800f,300f,mPaint)
```

![setColor](https://ForLovelj.github.io/img/setColor.png)

### 设置基本颜色 setARGB(int a, int r, int g, int b)

```kotlin
    mPaint.strokeWidth = 40f
    mPaint.setARGB(100,255,0,0)
    canvas.drawLine(100f,100f,800f,100f,mPaint)

    mPaint.setARGB(100,0,255,0)
    canvas.drawLine(100f,200f,800f,200f,mPaint)

    mPaint.setARGB(255,0,0,255)
    canvas.drawLine(100f,300f,800f,300f,mPaint)
```

![setARGB](https://ForLovelj.github.io/img/setARGB.png)

### 设置着色器 setShader(Shader shader)

除了直接设置颜色， `Paint` 还可以使用 `Shader` 。

`Shader` 的中文叫做「着色器」，也是用于设置绘制颜色的。「着色器」不是 `Android` 独有的，它是图形领域里一个通用的概念，它和直接设置颜色的区别是，着色器设置的是一个颜色方案，或者说是一套着色规则。当设置了 `Shader` 之后，`Paint` 在绘制图形和文字时就不使用 `setColor/ARGB()` 设置的颜色了，而是使用 `Shader` 的方案中的颜色。

在 `Android` 的绘制里使用 `Shader` ，并不直接用 `Shader` 这个类，而是用它的几个子类。具体来讲有 `LinearGradient` `RadialGradient` `SweepGradient` `BitmapShader` `ComposeShader` 这么几个：

#### 线性渐变 LinearGradient

设置两个点和两种颜色，以这两个点作为端点，使用两种颜色的渐变来绘制颜色。

构造方法：

```java
    /**
     * @param x0       渐变线开始的x坐标
     * @param y0       渐变线开始的y坐标
     * @param x1       渐变线结束的x坐标
     * @param y1       渐变线结束的y坐标
     * @param color0   渐变开始的颜色
     * @param color1   渐变结束的颜色
     * @param tile     渐变开始和结束点范围之外的着色规则
     */
    public LinearGradient(float x0, float y0, float x1, float y1,int color0, int color1,TileMode tile)

    /**
     * @param x0       渐变线开始的x坐标
     * @param y0       渐变线开始的y坐标
     * @param x1       渐变线结束的x坐标
     * @param y1       渐变线结束的y坐标
     * @param colors   颜色数组
     * @param positions    颜色数组中每个颜色对应的相对位置，取值范围(0~1)，positions数组元素的个数一定colors数组的个数相同如果为null，则沿渐变线均匀分布
     * @param tile         渐变开始和结束点范围之外的着色规则
     */
    public LinearGradient(float x0, float y0, float x1, float y1, @NonNull int[] colors,@Nullable float[] positions, @NonNull TileMode tile)

    ...
```

这里我们用第一种构造方法作演示：

```kotlin
    //CLAMP 渐变开始和结束点范围之外 用相邻位置的颜色填充
    val shader = LinearGradient(100f,100f,500f,200f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.CLAMP)
    mPaint.shader = shader
    canvas.drawRect(100f,100f,900f,200f,mPaint)

    //MIRROR    镜像填充
    val shader1 = LinearGradient(100f,300f,500f,400f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.MIRROR)
    mPaint.shader = shader1
    canvas.drawRect(100f,300f,900f,400f,mPaint)

    //REPEAT    重复填充
    val shader2 = LinearGradient(100f,500f,500f,600f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.REPEAT)
    mPaint.shader = shader2
    canvas.drawRect(100f,500f,900f,600f,mPaint)

    //DECAL api >= 31 仅填充渐变开始和结束点范围。如果超出其原始边界，则绘制透明黑色。
    val shader3 = LinearGradient(100f,700f,500f,800f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.DECAL)
    mPaint.shader = shader3
    canvas.drawRect(100f,700f,900f,800f,mPaint)
```

![LinearGradient](https://ForLovelj.github.io/img/LinearGradient.png)

#### 辐射渐变 RadialGradient

辐射渐变很好理解，就是从中心向周围辐射状的渐变。

构造方法：

```java
    /**
     * @param centerX     辐射中心的x坐标
     * @param centerY     辐射中心的y坐标
     * @param radius      辐射半径
     * @param centerColor 辐射中心的颜色
     * @param edgeColor   辐射边缘的颜色
     * @param tileMode    辐射范围之外的着色模式
     */
    public RadialGradient(float centerX, float centerY, float radius,
            @ColorInt int centerColor, @ColorInt int edgeColor, @NonNull TileMode tileMode)

    ...
```

示例：
```kotlin
    //CLAMP
    val shader = RadialGradient(300f,300f,150f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.CLAMP)
    mPaint.shader = shader
    canvas.drawCircle(300f,300f,150f,mPaint)

    //MIRROR
    val shader1 = RadialGradient(300f,600f,50f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.MIRROR)
    mPaint.shader = shader1
    canvas.drawCircle(300f,600f,150f,mPaint)

    //REPEAT
    val shader2 = RadialGradient(300f,900f,50f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.REPEAT)
    mPaint.shader = shader2
    canvas.drawCircle(300f,900f,150f,mPaint)

    //DECAL
    val shader3 = RadialGradient(300f,1200f,50f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"),Shader.TileMode.DECAL)
    mPaint.shader = shader3
    canvas.drawCircle(300f,1200f,150f,mPaint)
```

![RadialGradient](https://ForLovelj.github.io/img/RadialGradient.png)

#### 扫描渐变 SweepGradient

构造方法：

```java
    /**
     * @param cx       扫描的中心x坐标
     * @param cy       扫描的中心y坐标
     * @param color0   扫描的起始颜色
     * @param color1   扫描的终止颜色
     */
    public SweepGradient(float cx, float cy, @ColorInt int color0, @ColorInt int color1)

    ...
```

示例：

```kotlin
    val shader = SweepGradient(300f,300f,Color.parseColor("#FF7400"),
        Color.parseColor("#BB86FC"))
    mPaint.shader = shader
    canvas.drawCircle(300f,300f,200f,mPaint)
```
![SweepGradient](https://ForLovelj.github.io/img/SweepGradient.png)

#### BitmapShader

用 `Bitmap` 来着色，其实也就是用 `Bitmap` 的像素来作为图形或文字的填充.

```kotlin
    val bitmap = BitmapFactory.decodeResource(resources, R.mipmap.beauty1)
    //CLAMP 当所画图形的尺寸大于bitmap的尺寸，会用bitmap和剩余空间相邻位置的颜色填充剩余空间
    //当所画图形的尺寸小于bitmap的尺寸，会对bitmap进行裁剪，利用这个原理，我们可以去制造圆形头像
    val shader = BitmapShader(bitmap,Shader.TileMode.CLAMP,Shader.TileMode.CLAMP)
    mPaint.shader = shader
    canvas.drawCircle(400f,400f,300f,mPaint)

    //另外几种填充方式和之前渐变一样，这儿不再赘述
//        val shader = BitmapShader(bitmap,Shader.TileMode.MIRROR,Shader.TileMode.MIRROR)
//        canvas.drawRect(0f,0f,canvas.width.toFloat(),canvas.height.toFloat(),mPaint)
```

![BitmapShader](https://ForLovelj.github.io/img/BitmapShader.png)

#### 混合着色器 ComposeShader