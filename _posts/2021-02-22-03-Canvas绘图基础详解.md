---
layout: post
title: 03-Canvas绘图基础详解
author: clow
date: 2021-02-22 20:20:15
categories:
- Android
tags: 自定义View
---

# 一、前言
Android中，如果我们想绘制复杂的自定义View或游戏，我们就需要熟悉绘图API。Android通过Canvas类暴露了很多drawXXX方法，我们可以通过这些方法绘制各种各样的图形。Canvas绘图有三个基本要素：`Canvas`、`绘图坐标系`以及`Paint`。Canvas是画布，我们通过Canvas的各种drawXXX方法将图形绘制到Canvas上面，在drawXXX方法中我们需要传入要绘制的图形的坐标形状，还要传入一个画笔Paint。drawXXX方法以及传入其中的坐标决定了要绘制的图形的形状，比如drawCircle方法，用来绘制圆形，需要我们传入圆心的x和y坐标，以及圆的半径。drawXXX方法中传入的画笔Paint决定了绘制的图形的一些外观，比如是绘制的图形的颜色，再比如是绘制圆面还是圆的轮廓线等。

# 二、Canvas的常用操作速查表

| 操作类型       | 相关API                                    | 备注                                       |
| ---------- | ---------------------------------------- | ---------------------------------------- |
| 绘制颜色       | drawColor, drawRGB, drawARGB             | 使用单一颜色填充整个画布                             |
| 绘制基本形状     | drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc | 依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧                  |
| 绘制图片       | drawBitmap, drawPicture                  | 绘制位图和图片                                  |
| 绘制文本       | drawText,    drawPosText, drawTextOnPath | 依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字          |
| 绘制路径       | drawPath                                 | 绘制路径，绘制贝塞尔曲线时也需要用到该函数                    |
| 顶点操作       | drawVertices, drawBitmapMesh             | 通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用 |
| 画布剪裁       | clipPath,    clipRect                    | 设置画布的显示区域                                |
| 画布快照       | save, restore, saveLayerXxx, restoreToCount, getSaveCount | 依次为 保存当前状态、 回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数 |
| 画布变换       | translate, scale, rotate, skew           | 依次为 位移、缩放、 旋转、错切                         |
| Matrix(矩阵) | getMatrix, setMatrix, concat             | 实际画布的位移，缩放等操作的都是图像矩阵Matrix，只不过Matrix比较难以理解和使用，故封装了一些常用的方法。 |

> PS： Canvas常用方法在上面表格中已经全部列出了，当然还存在一些其他的方法未列出，具体可以参考官方文档 [Canvas](http://developer.android.com/reference/android/graphics/Canvas.html)

# 三、Canvas Api梳理

## 1. Canvas坐标系与绘图坐标系

- **Canvas坐标系：** Canvas坐标系指的是Canvas本身的坐标系，Canvas坐标系有且只有一个，且是唯一不变的，其坐标原点在View的左上角，从坐标原点向右为x轴的正半轴，从坐标原点向下为y轴的正半轴。

- **绘图坐标系：** `Canvas`的`drawXXX`方法中传入的各种坐标指的都是绘图坐标系中的坐标，而非`Canvas`坐标系中的坐标。默认情况下，绘图坐标系与`Canvas`坐标系完全重合，即初始状况下，绘图坐标系的坐标原点也在`View`的左上角，从原点向右为x轴正半轴，从原点向下为y轴正半轴。但不同于`Canvas`坐标系，绘图坐标系并不是一成不变的，可以通过调用`Canvas`的`translate`方法平移坐标系，可以通过`Canvas`的`rotate`方法旋转坐标系，还可以通过`Canvas`的`scale`方法缩放坐标系，而且需要注意的是，`translate`、`rotate`、`scale`的操作都是基于当前绘图坐标系的，而不是基于`Canvas`坐标系，一旦通过以上方法对坐标系进行了操作之后，当前绘图坐标系就变化了，以后绘图都是基于更新的绘图坐标系了。也就是说，真正对我们绘图有用的是绘图坐标系而非`Canvas`坐标系。

为了更好的理解绘图坐标系，请看如下代码：

``` kotlin

    /**
     * 绘制坐标系
     */
    private fun drawAxis(canvas: Canvas) {
        val canvasWidth = canvas.width.toFloat()
        val canvasHeight= canvas.height.toFloat()
        mPaint.setColor(Color.GREEN)
        mPaint.strokeWidth = 8f
        //第一次绘制坐标轴(默认情况下的绘图坐标系)
        canvas.drawLine(0f,0f,canvasWidth,0f,mPaint)//绘制x轴
        canvas.drawLine(0f,0f,0f,canvasHeight,mPaint)//绘制Y轴
        //绘制一个矩形
        mPaint.setColor(Color.BLUE)
        val rect = RectF(100F, 100F, 200F, 200F)
        canvas.drawRect(rect,mPaint)

        //对坐标系平移后，第二次绘制坐标轴
        canvas.translate(300f,300f)
        mPaint.setColor(Color.RED)
        canvas.drawLine(0f,0f,canvasWidth,0f,mPaint)//绘制x轴
        canvas.drawLine(0f,0f,0f,canvasHeight,mPaint)//绘制Y轴
        //绘制一个矩形
        mPaint.setColor(Color.BLUE)
        canvas.drawRect(rect,mPaint)

        //对坐标系旋转，第三次绘制坐标轴
        canvas.rotate(30f)
        mPaint.setColor(Color.BLACK)
        canvas.drawLine(0f,0f,canvasWidth,0f,mPaint)//绘制x轴
        canvas.drawLine(0f,0f,0f,canvasHeight,mPaint)//绘制Y轴
        //绘制一个矩形
        mPaint.setColor(Color.BLUE)
        canvas.drawRect(rect,mPaint)
    }

```

界面如下图所示：

![绘制坐标系](https://ForLovelj.github.io/img/绘制坐标系.png)

图中黑色坐标代表View的坐标系，红色的坐标代表绘图的坐标系。

第一次绘制坐标轴时（绿色），可以看到，默认情况下View的坐标系和绘图的坐标系重合

第二次绘制坐标轴时（红色），可以看到绘图坐标系的坐标原点被移动到(300,300)，而View的坐标系没有改变，绘制内容是基于绘图坐标系来绘制的。

第三次绘制坐标轴时（黑色），将绘图的坐标系顺时针旋转了30°，View的坐标系还是没有改变，绘制内容是基于绘图坐标系来绘制的。

从上我们可以知道，在绘制内容时是根据绘图的坐标系来绘制的，我们对Canvas的操作只是改变了绘图坐标系跟View的坐标系无关。

## 2. 画布操作

画布的操作可以让我们绘制出更多的效果，这里要注意一点，就是画布Canvas的概念，虽然翻译为画布，其实它是绘制的规则，真正绘制是在屏幕上，所以当画布平移、裁剪等操作只针对于画布来说，对其View的大小和位置没有影响。

**Q：为什么要有画布操作？**

**A：画布操作可以帮助我们用更加容易理解的方式制作图形。**

**例如： 从坐标原点为起点，绘制一个长度为20dp，与水平线夹角为30度的线段怎么做？**

**按照我们通常的想法(被常年训练出来的数学思维)，就是先使用三角函数计算出线段结束点的坐标，然后调用drawLine即可。**

**然而这是否是被固有思维禁锢了？**

**假设我们先绘制一个长度为20dp的水平线，然后将这条水平线旋转30度，则最终看起来效果是相同的，而且不用进行三角函数计算，这样是否更加简单了一点呢？**

**合理的使用画布操作可以帮助你用更容易理解的方式创作你想要的效果，这也是画布操作存在的原因。**

### 2.1 平移(translate)

translate是坐标系的移动，可以为图形绘制选择一个合适的坐标系。 请注意，位移是基于当前位置移动，而不是每次基于屏幕左上角的(0,0)点移动，如下：

``` kotlin
       // 在坐标原点绘制一个黑色圆形
        mPaint.style = Paint.Style.FILL
        mPaint.setColor(Color.BLACK)
        canvas.translate(200f,200f)
        canvas.drawCircle(0f,0f,100f,mPaint)

        // 在坐标原点绘制一个蓝色圆形
        mPaint.setColor(Color.BLUE)
        canvas.translate(200f,200f)
        canvas.drawCircle(0f,0f,100f,mPaint)
```
效果如下：

![画布平移](https://ForLovelj.github.io/img/画布平移.png)

我们首先将坐标系移动一段距离绘制一个圆形，之后再移动一段距离绘制一个圆形，**两次移动是可叠加的**。 

### 2.2 缩放(scale)

缩放提供了两个方法，如下：
``` java
 public void scale (float sx, float sy)

 public final void scale (float sx, float sy, float px, float py)
```

这两个方法中前两个参数是相同的分别为x轴和y轴的缩放比例。而第二种方法比前一种多了两个参数，用来控制缩放中心位置的。

缩放比例(sx,sy)取值范围详解：

| 取值范围(n) | 说明                                           |
| ----------- | ---------------------------------------------- |
| (-∞, -1)    | 先根据缩放中心放大n倍，再根据中心轴进行翻转    |
| -1          | 根据缩放中心轴进行翻转                         |
| (-1, 0)     | 先根据缩放中心缩小到n，再根据中心轴进行翻转    |
| 0           | 不会显示，若sx为0，则宽度为0，不会显示，sy同理 |
| (0, 1)      | 根据缩放中心缩小到n                            |
| 1           | 没有变化                                       |
| (1, +∞)     | 根据缩放中心放大n倍                            |

如果在缩放时稍微注意一下就会发现**缩放的中心默认为坐标原点,而缩放中心轴就是坐标轴**，如下：

``` kotlin
    val canvasWidth = canvas.width.toFloat()
    val canvasHeight= canvas.height.toFloat()
    //画布原点平移到中心
    canvas.translate(canvasWidth/2,canvasHeight/2)
    //绘制坐标系
    mPaint.style = Paint.Style.STROKE
    mPaint.setColor(Color.RED)
    mPaint.strokeWidth = 4f
    canvas.drawLine(-canvasWidth/2,0f,canvasWidth/2,0f,mPaint)//x轴
    canvas.drawLine(0f,-canvasHeight/2,0f,canvasHeight/2,mPaint)//y轴


    val rect = RectF(0F, 0F, 400F, 400F)    // 矩形区域
    mPaint.setColor(Color.BLACK)
    canvas.drawRect(rect, mPaint)       //绘制黑色矩形

    canvas.scale(0.5f,0.5f)      // 画布缩放

    mPaint.setColor(Color.BLUE)
    canvas.drawRect(rect, mPaint)      //再绘制蓝色矩形
```

(为了更加直观，我添加了一个坐标系，可以比较明显的看出，缩放中心就是坐标原点)

![画布缩放1](https://ForLovelj.github.io/img/画布缩放1.png)

接下来我们使用第二种方法让缩放中心位置稍微改变一下，如下：

``` kotlin
    val rect = RectF(0F, 0F, 400F, 400F)    // 矩形区域
    mPaint.setColor(Color.BLACK)
    canvas.drawRect(rect, mPaint)       //绘制黑色矩形

    canvas.scale(0.5f,0.5f,200f,0f)   // 画布缩放  <-- 缩放中心向右偏移了200个单位

    mPaint.setColor(Color.BLUE)
    canvas.drawRect(rect, mPaint)      //再绘制蓝色矩形
```

![画布缩放2](https://ForLovelj.github.io/img/画布缩放2.png)

前面两个示例缩放的数值都是正数，按照表格中的说明，当缩放比例为负数的时候会根据缩放中心轴进行翻转，下面我们就来实验一下：

``` kotlin
    canvas.scale(-0.5f,-0.5f)         // 画布缩放
```

![画布缩放3](https://ForLovelj.github.io/img/画布缩放3.png)

为了效果明显，我对两个矩形中几个重要的点进行了标注，具有相同字母标注的点是一一对应的。

由于本次未对缩放中心进行偏移，所有默认的**缩放中心就是坐标原点，中心轴就是x轴和y轴**。

本次缩放可以看做是**先根据缩放中心(坐标原点)缩放到原来的0.5倍**，然后**分别按照x轴和y轴进行翻转**。

``` kotlin
    canvas.scale(-0.5f,-0.5f,200f,0f)  // 画布缩放  <-- 缩放中心向右偏移了200个单位
```

![画布缩放4](https://ForLovelj.github.io/img/画布缩放4.png)

本次对缩放中心点坐标进行了偏移，故中心轴也向右偏移了。**注意翻转是根据缩放中心轴进行的**。

**PS:和位移(translate)一样，缩放也是可以叠加的。**
``` kotlin
    canvas.scale(0.5f,0.5f)
    canvas.scale(0.5f,0.1f)
```

调用两次缩放则 x轴实际缩放为0.5x0.5=0.25 y轴实际缩放为0.5x0.1=0.05

下面我们利用这一特性制作一个有趣的图形。

``` kotlin
    val canvasWidth = canvas.width.toFloat()
    val canvasHeight= canvas.height.toFloat()
    //画布原点平移到中心
    canvas.translate(canvasWidth/2,canvasHeight/2)
    mPaint.style = Paint.Style.STROKE
    mPaint.setColor(Color.BLACK)
    mPaint.strokeWidth = 20f
    val rect = RectF(-400f, -400f, 400f, 400f) // 矩形区域

    for (i in 0..20) {
        canvas.scale(0.9f, 0.9f)
        canvas.drawRect(rect, mPaint)
    }
```

![画布缩放demo](https://ForLovelj.github.io/img/画布缩放demo.png)

### 2.3 旋转(rotate)

旋转提供了两种方法：

``` java
    public void rotate (float degrees)
  
    public final void rotate (float degrees, float px, float py)
```

和缩放一样，第二种方法多出来的两个参数依旧是控制旋转中心点的。

默认的旋转中心依旧是坐标原点：

``` kotlin
    val canvasWidth = canvas.width.toFloat()
    val canvasHeight= canvas.height.toFloat()
    //画布原点平移到中心
    canvas.translate(canvasWidth/2,canvasHeight/2)
    //绘制坐标系
    mPaint.style = Paint.Style.STROKE
    mPaint.setColor(Color.RED)
    mPaint.strokeWidth = 4f
    canvas.drawLine(-canvasWidth/2,0f,canvasWidth/2,0f,mPaint)//x轴
    canvas.drawLine(0f,-canvasHeight/2,0f,canvasHeight/2,mPaint)//y轴

    val rect = RectF(0F, 0F, 200F, 200F)
    mPaint.setColor(Color.BLACK)
    canvas.drawRect(rect, mPaint)   //绘制黑色矩形
    //顺时针旋转45°
    canvas.rotate(45f)

    //绘制旋转后的绿色坐标轴
    mPaint.setColor(Color.GREEN)
    canvas.drawLine(-canvasWidth/2,0f,canvasWidth/2,0f,mPaint)//x轴
    canvas.drawLine(0f,-canvasHeight/2,0f,canvasHeight/2,mPaint)//y轴

    mPaint.setColor(Color.BLUE)
    canvas.drawRect(rect, mPaint)   //绘制蓝色矩形
```

![画布旋转1](https://ForLovelj.github.io/img/画布旋转1.png)

旋转前canvas是红色坐标系，旋转后canvas是绿色坐标系，可以看到canvas沿着旋转中心顺时针旋转了45度。

改变旋转中心位置：

``` kotlin
    canvas.rotate(45f,100f,0f)  // 旋转45度 <-- 旋转中心向右偏移100个单位
```

![画布旋转2](https://ForLovelj.github.io/img/画布旋转2.png)

可以看到canvas是基于旋转中心旋转的。

**PS:同样，旋转也是可以叠加的。**

``` kotlin
    canvas.rotate(180)
    canvas.rotate(20)
```

调用两次旋转，则实际的旋转角度为180+20=200度。

为了演示这一个效果，我们来做一个刻度盘：

``` kotlin
    val canvasWidth = canvas.width.toFloat()
    val canvasHeight= canvas.height.toFloat()
    //画布原点平移到中心
    canvas.translate(canvasWidth/2,canvasHeight/2)
    mPaint.style = Paint.Style.STROKE
    mPaint.strokeWidth = 10f
    mPaint.setColor(Color.BLACK)
    canvas.drawCircle(0f,0f,400f,mPaint) //绘制表盘

    mPaint.strokeWidth = 4f
    val textPaint = TextPaint().apply {
        textSize = 18f
        isAntiAlias = true
        textAlign = Paint.Align.CENTER
    }
    for (i in 0..360 step 30) {
        canvas.drawLine(0f,-380f,0f,-400f,mPaint)   //绘制刻度
        if (i != 0) {
            canvas.save()
            canvas.rotate(-i.toFloat(),0f,-360f)    //逆时针旋转数字对应的角度 使数字全部正向
            canvas.drawText("${i/30}",0f,-360f,textPaint)   //绘制数字
            canvas.restore()
        }
        canvas.rotate(30f)
    }
```

![画布旋转demo](https://ForLovelj.github.io/img/画布旋转demo.png)

### 2.4 错切(skew)

skew这里翻译为错切，错切是特殊类型的线性变换。

错切只提供了一种方法：

``` java
    public void skew (float sx, float sy)
```

**参数含义：**

- float sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值.
- float sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值.

变换后的点(X,Y)和变换前的点(x,y)映射关系:

```
    X = x + sx * y
    Y = sy * x + y
```

示例：
``` kotlin
    val canvasWidth = canvas.width.toFloat()
    val canvasHeight= canvas.height.toFloat()
    //画布原点平移到中心
    canvas.translate(canvasWidth/2,canvasHeight/2)
    //绘制坐标系
    mPaint.style = Paint.Style.STROKE
    mPaint.setColor(Color.RED)
    mPaint.strokeWidth = 4f
    canvas.drawLine(-canvasWidth/2,0f,canvasWidth/2,0f,mPaint)//x轴
    canvas.drawLine(0f,-canvasHeight/2,0f,canvasHeight/2,mPaint)//y轴

    val rect = RectF(0F, 0F, 200F, 200F)
    mPaint.setColor(Color.BLACK)
    canvas.drawRect(rect, mPaint)   //绘制黑色矩形
    //画布往X方向倾斜45度
    canvas.skew(1f,0f)  // 水平错切 <- 45度

    mPaint.setColor(Color.BLUE)
    canvas.drawRect(rect, mPaint)   //绘制蓝色矩形
```

![画布错切](https://ForLovelj.github.io/img/画布错切.png)

通过上面说到的变化前后点位映射关系可以算出错切前的B(200,200),错且后的坐标为B'(400,200)。

## 3. 画布快照

### 3.1 快照(save)和回滚(restore)

**Q: 为什么存在快照与回滚**

**A：画布的操作是不可逆的，而且很多画布操作会影响后续的步骤，例如第一个例子，两个圆形都是在坐标原点绘制的，而因为坐标系的移动绘制出来的实际位置不同。所以会对画布的一些状态进行保存和回滚。**

与之相关的API:

| 相关API          | 简介                             |
| -------------- | ------------------------------ |
| save           | 把当前的画布的状态进行保存，然后放入特定的栈中        |
| saveLayerXxx   | 新建一个图层，并放入特定的栈中                |
| restore        | 把栈中最顶层的画布状态取出来，并按照这个状态恢复当前的画布  |
| restoreToCount | 弹出指定位置及其以上所有的状态，并按照指定位置的状态进行恢复 |
| getSaveCount   | 获取栈中内容的数量(即保存次数)               |

下面对其中的一些概念和方法进行分析：

1. 画布状态：当前画布经过的一些列操作。
2. 状态栈：存放画布状态和图层的栈，后进先出。

![画布状态栈](https://ForLovelj.github.io/img/画布状态栈.png)

3. 画布的构成：由多个图层构成：

![图层](https://ForLovelj.github.io/img/图层.png)

所以有如下结论：

- 在画布上操作 = 在图层上操作。
- 如无设置，绘制操作和画布操作默认是在默认图层上进行。
- 在通常情况下，使用默认图层可以满足需求；若需要绘制复杂的内容(比如地图)，则需要使用更多的图层。
- 最终显示的结果 = 所有图层叠在一起的效果。

#### SaveFlags

| 数据类型 | 名称                         | 简介                                       |
| ---- | -------------------------- | ---------------------------------------- |
| int  | ALL_SAVE_FLAG              | 默认，保存全部状态                                |
| int  | CLIP_SAVE_FLAG             | 保存剪辑区                                    |
| int  | CLIP_TO_LAYER_SAVE_FLAG    | 剪裁区作为图层保存                                |
| int  | FULL_COLOR_LAYER_SAVE_FLAG | 保存图层的全部色彩通道                              |
| int  | HAS_ALPHA_LAYER_SAVE_FLAG  | 保存图层的alpha(不透明度)通道                       |
| int  | MATRIX_SAVE_FLAG           | 保存Matrix信息(translate, rotate, scale, skew) |

#### save

save 有两种方法：

``` java
  // 保存全部状态
  public int save ()
  
  // 根据saveFlags参数保存一部分状态
  public int save (int saveFlags)
```

可以看到第二种方法比第一种多了一个saveFlags参数，使用这个参数可以只保存一部分状态，更加灵活，这个saveFlags参数具体可参考上面表格中的内容。

每调用一次save方法，都会在栈顶添加一条状态信息，以上面状态栈图片为例，再调用一次save则会在第5次上面载添加一条状态。

#### saveLayerXxx

saveLayerXxx有比较多的方法：

``` java
    // 无图层alpha(不透明度)通道
    public int saveLayer (RectF bounds, Paint paint)
    public int saveLayer (RectF bounds, Paint paint, int saveFlags)
    public int saveLayer (float left, float top, float right, float bottom, Paint paint)
    public int saveLayer (float left, float top, float right, float bottom, Paint paint, int saveFlags)

    // 有图层alpha(不透明度)通道
    public int saveLayerAlpha (RectF bounds, int alpha)
    public int saveLayerAlpha (RectF bounds, int alpha, int saveFlags)
    public int saveLayerAlpha (float left, float top, float right, float bottom, int alpha)
    public int saveLayerAlpha (float left, float top, float right, float bottom, int alpha, int saveFlags)
```

**注意：saveLayerXxx方法会让你花费更多的时间去渲染图像(图层多了相互之间叠加会导致计算量成倍增长)，使用前请谨慎，如果可能，尽量避免使用。**

使用saveLayerXxx方法，也会将图层状态也放入状态栈中，同样使用restore方法进行恢复。

#### restore
状态回滚，就是从栈顶取出一个状态然后根据内容进行恢复。

同样以上面状态栈图片为例，调用一次restore方法则将状态栈中第5次取出，根据里面保存的状态进行状态恢复。

#### restoreToCount
弹出指定位置以及以上所有状态，并根据指定位置状态进行恢复。

以上面状态栈图片为例，如果调用restoreToCount(2) 则会弹出 2 3 4 5 的状态，并根据第2次保存的状态进行恢复。

#### getSaveCount
获取保存的次数，即状态栈中保存状态的数量，以上面状态栈图片为例，使用该函数的返回值为5。

不过请注意，该函数的最小返回值为1，即使弹出了所有的状态，返回值依旧为1，代表默认状态。

#### 常用格式
虽然关于状态的保存和回滚啰嗦了不少，不过大多数情况下只需要记住下面的步骤就可以了：
``` kotlin
   canvas.save()      //保存状态
   ...                //具体操作
   canvas.restore()   //回滚到之前的状态
```
这种方式也是最简单和最容易理解的使用方法。

## 4. 绘制颜色

文章开头讲到Canvas绘图有三个基本要素：`Canvas`、`绘图坐标系`以及`Paint`，要想绘制内容，首先需要先创建一个画笔，`Paint` 类的几个最常用的方法如下：

```
    private val mPaint = Paint().apply {
        style = Paint.Style.STROKE  //设置绘制模式
        color = Color.BLACK //设置颜色
        strokeWidth = 4f    //设置线条宽度
        textSize = 18f      //设置文字大小
        isAntiAlias = true  //抗锯齿开关
        ...
    }
```

### 4.1 安卓支持的颜色模式

在讲绘制颜色前，我们先来了解下安卓支持的颜色模式：

颜色模式 | 备注
:--- | ---
ARGB8888 | 四通道高精度(32位)
ARGB4444 | 四通道低精度(16位)
RGB565   | **屏幕默认模式**(16位)
Alpha8   | 仅有透明通道(8位)

**PS：其中字母表示通道类型，数值表示该类型用多少位二进制来描述。如ARGB8888则表示有四个通道(ARGB),每个对应的通道均用8位来描述。**

**注意：我们常用的是ARGB8888和ARGB4444，而在所有的安卓设备屏幕上默认的模式都是RGB565,请留意这一点。**

**以ARGB8888为例介绍颜色定义:**

类型      | 解释   | 0(0x00) | 255(0xff) 
:-------- |:------ | :------ | :--------
A(Alpha)  | 透明度 | 透明    | 不透明
R(Red)    | 红色   | 无色    | 红色
G(Green)  | 绿色   | 无色    | 绿色
B(Blue)   | 蓝色   | 无色    | 蓝色 

**其中 A R G B 的取值范围均为0~255(即16进制的0x00~0xff)**

A 从0x00到0xff表示从透明到不透明。

RGB 从0x00到0xff表示颜色从浅到深。

**当RGB全取最小值(0或0x000000)时颜色为黑色，全取最大值(255或0xffffff)时颜色为白色**

### 4.2 几种创建或使用颜色的方式

#### 1.java中定义颜色

``` java
  int color = Color.GRAY;     //灰色
```

  由于Color类提供的颜色仅为有限的几个，通常还是用ARGB值进行表示。

``` java
  int color = Color.argb(127, 255, 0, 0);   //半透明红色
  
  int color = 0xaaff0000;                   //带有透明度的红色
```

#### 2.在xml文件中定义颜色

在/res/values/color.xml 文件中如下定义：

``` xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="red">#ff0000</color>
    <color name="green">#00ff00</color>
</resources>
```

详解： 在以上xml文件中定义了两个颜色，红色和蓝色，是没有alpha（透明）通道的。

定义颜色以‘#’开头，后面跟十六进制的值，有如下几种定义方式：

``` java
  #f00            //低精度 - 不带透明通道红色
  #af00           //低精度 - 带透明通道红色
  
  #ff0000         //高精度 - 不带透明通道红色
  #aaff0000       //高精度 - 带透明通道红色
```

#### 3.在java文件中引用xml中定义的颜色：

``` java
  int color = getResources().getColor(R.color.mycolor);
  
  int color = getColor(R.color.myColor);    //API 23 及以上支持该方法
```

#### 4.在xml文件(layout或style)中引用或者创建颜色

``` xml
    <!--在style文件中引用-->
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        <item name="colorPrimary">@color/red</item>
    </style>
```

``` java
  android:background="@color/red"     //引用在/res/values/color.xml 中定义的颜色
  
  android:background="#ff0000"        //创建并使用颜色
```

### 4.3 颜色混合模式(Alpha通道相关)

通过前面介绍我们知道颜色一般都是四个通道(ARGB)的，其中(RGB)控制的是颜色,而A(Alpha)控制的是透明度。

因为我们的显示屏是没法透明的，因此最终显示在屏幕上的颜色里可以认为没有Alpha通道。Alpha通道主要在两个图像混合的时候生效。

默认情况下，当一个颜色绘制到Canvas上时的混合模式是这样计算的：

**(RGB通道) 最终颜色 = 绘制的颜色 + (1 - 绘制颜色的透明度) × Canvas上的原有颜色。**

**注意：**

1.这里我们一般把每个通道的取值从0(0x00)到255(0xff)映射到0到1的浮点数表示。

2.这里等式右边的“绘制的颜色"、“Canvas上的原有颜色”都是经过预乘了自己的Alpha通道的值。如绘制颜色：0x88ffffff，那么参与运算时的每个颜色通道的值不是1.0，而是(1.0 * 0.5333 = 0.5333)。  (其中0.5333 = 0x88/0xff)

使用这种方式的混合，就会造成后绘制的内容以半透明的方式叠在上面的视觉效果。

其实还可以有不同的混合模式供我们选择，用`Paint.setXfermode`，指定不同的`PorterDuff.Mode`，这个在我们后续讲`paint`的时候再细说，可以查看[官方文档](https://developer.android.com/reference/android/graphics/PorterDuff.Mode)了解。

### 4.2 绘制颜色
相关API是`drawColor`，可以在**整个绘制区域统一涂上指定的颜色**，因为它没有指定范围，所以范围就是Canvas所绘制的范围。

一般用来绘制背景，或者绘制一个遮盖：

``` kotlin
    canvas.drawColor(Color.BLUE)    //绘制蓝色
```

![绘制颜色](https://ForLovelj.github.io/img/绘制颜色.png)

## 5. 绘制基本形状

### 5.1 绘制点(drawPoint)
点的大小可以通过 `paint.setStrokeWidth(width)` 来设置；点的形状可以通过 `paint.setStrokeCap(cap)` 来设置：`ROUND` 画出来是圆形的点，`SQUARE` 或 `BUTT` 画出来是方形的点。

> 注：Paint.setStrokeCap(cap) 可以设置点的形状，但这个方法并不是专门用来设置点的形状的，而是一个设置线条端点形状的方法。端点有圆头 (ROUND)、平头 (BUTT) 和方头 (SQUARE) 三种。

``` kotlin
    mPaint.style = Paint.Style.FILL //设置填充模式
    mPaint.color = Color.BLACK  //设置画笔颜色
    mPaint.strokeWidth = 20f    //设置画笔宽度为20px

    canvas.drawPoint(200f, 200f, mPaint)//在坐标(200,200)位置绘制一个点

    mPaint.strokeCap = Paint.Cap.ROUND  //绘制圆点

    canvas.drawPoints(
        //绘制一组点，坐标位置由float数组指定
        floatArrayOf(
            500f, 500f,
            500f, 600f,
            500f, 700f
        ), mPaint
    )

    canvas.drawPoints(
        //绘制一组点，坐标位置由float数组指定
        floatArrayOf(
            500f, 500f,
            500f, 600f,
            500f, 700f
        ), mPaint
    )

    mPaint.color = Color.RED
    canvas.drawPoints(
        //绘制一组点，坐标位置由float数组指定
        floatArrayOf(
            600f, 500f,
            600f, 600f,
            600f, 700f
        ),
        2,//跳过前两个数即600,500
        4,//一共绘制4个数（2个点）
        mPaint
    )
```

![绘制点](https://ForLovelj.github.io/img/绘制点.png)

### 5.2 绘制线(drawLine)

``` kotlin

    mPaint.style = Paint.Style.FILL //设置填充模式
    mPaint.color = Color.BLACK  //设置画笔颜色
    mPaint.strokeWidth = 20f    //设置画笔宽度为20px

    //以(400,400)为起点，(700,700)为终点绘制一条直线
    canvas.drawLine(400f,400f,700f,700f,mPaint)

    //批量绘制
    canvas.drawLines(
        floatArrayOf(
            100f,800f,400f,800f,
            100f,900f,400f,900f
        ),mPaint
    )

    mPaint.color = Color.RED    //画笔设置为红色
    mPaint.strokeCap = Paint.Cap.ROUND  //端点设置为圆头
    canvas.drawLines(
        floatArrayOf(
            100f,800f,400f,800f,
            100f,900f,400f,900f,
            100f,1000f,400f,1000f,
        ),
        8,//跳过8个数
        4,//绘制4个数（一条线）
        mPaint
    )
```

![绘制线](https://ForLovelj.github.io/img/绘制线.png)

### 5.3 绘制矩形(drawRect)

我们都知道，确定一个矩形最少需要四个数据，就是**对角线的两个点的坐标值**，这里**一般采用左上角和右下角的两个点的坐标**。

关于绘制矩形，Canvas提供了三种重载方法，第一种就是提供四个数值(矩形左上角和右下角两个点的坐标)来确定一个矩形进行绘制。 其余两种是先将矩形封装为Rect或RectF(实际上仍然是用两个坐标点来确定的矩形)，然后传递给Canvas绘制，如下：

``` kotlin
    mPaint.style = Paint.Style.FILL //设置填充模式
    mPaint.color = Color.BLACK  //设置画笔颜色
    mPaint.strokeWidth = 20f    //设置画笔宽度为20px

    //第一种
    canvas.drawRect(100f,100f,600f,400f,mPaint)

    //第二种
    canvas.drawRect(
        Rect(100,500,600,800),
        mPaint
    )

    //第三种
    canvas.drawRect(
        RectF(100f,900f,600f,1200f),
        mPaint
    )

    mPaint.style = Paint.Style.STROKE //设置描边模式
    canvas.drawRect(100f,1300f,600f,1600f,mPaint)
```

![绘制矩形](https://ForLovelj.github.io/img/绘制矩形.png)

### 5.4 绘制圆角矩形(drawRoundRect)

绘制圆角矩形也提供了两种重载方式，如下：

``` kotlin

    mPaint.style = Paint.Style.FILL //设置填充模式
    mPaint.color = Color.BLACK  //设置画笔颜色
    mPaint.strokeWidth = 20f    //设置画笔宽度为20px

    //第一种 left, top, right, bottom 是四条边的坐标，rx 和 ry 是圆角的横向半径和纵向半径
    canvas.drawRoundRect(100f,100f,600f,400f,30f,30f,mPaint)

    //第二种
    canvas.drawRoundRect(
        RectF(100f,500f,600f,800f),
        30f,30f,mPaint)

    mPaint.style = Paint.Style.STROKE //设置描边模式
    canvas.drawRoundRect(100f,900f,600f,1200f,30f,30f,mPaint)
```

![绘制圆角矩形](https://ForLovelj.github.io/img/绘制圆角矩形.png)

下面简单解析一下圆角矩形多出来的 `rx` 和 `ry` 参数的意思，如下图所示：

红线标注的 `rx` 与 `ry` 就是两个半径，也就是相比绘制矩形多出来的那两个参数，这里圆角矩形的角实际上不是一个正圆的圆弧，而是椭圆的圆弧，这里的两个参数实际上是椭圆的两个半径，实际上在rx为宽度的一半，ry为高度的一半时，我们绘制出来的圆角矩形刚好就是一个椭圆。

![绘制圆角矩形rxry参数](https://ForLovelj.github.io/img/绘制圆角矩形rxry参数.png)

### 5.5 绘制椭圆(drawOval)

绘制椭圆实际上就是绘制一个矩形的内切图形，所以只需要一个矩形作为参数:

``` kotlin
    mPaint.style = Paint.Style.FILL //设置填充模式
    mPaint.color = Color.BLACK  //设置画笔颜色
    mPaint.strokeWidth = 20f    //设置画笔宽度为20px

    //第一种 left, top, right, bottom 是这个椭圆的左、上、右、下四个边界点的坐标
    canvas.drawOval(100f,100f,600f,400f,mPaint)

    //第二种
    canvas.drawOval(
        RectF(100f,500f,600f,800f),
        mPaint
    )

    mPaint.style = Paint.Style.STROKE //设置描边模式
    canvas.drawOval(100f,900f,600f,1200f,mPaint)
```

![绘制椭圆](https://ForLovelj.github.io/img/绘制椭圆.png)

PS： 如果你传递进来的是一个长宽相等的矩形(即正方形)，那么绘制出来的实际上就是一个圆

### 5.6 绘制圆(drawCircle)

``` kotlin
    mPaint.style = Paint.Style.FILL //设置填充模式
    mPaint.color = Color.BLACK  //设置画笔颜色
    mPaint.strokeWidth = 20f    //设置画笔宽度为20px

    // 绘制一个圆心坐标在(500,500)，半径为300 的圆。
    canvas.drawCircle(500f,500f,300f,mPaint)

    mPaint.style = Paint.Style.STROKE //设置描边模式
    //画笔为描边模式绘制出来的是一个圆环
    canvas.drawCircle(500f,1200f,300f,mPaint)
```

![绘制圆](https://ForLovelj.github.io/img/绘制圆.png)

### 5.7 绘制圆弧(drawArc)

``` java
// 第一种
public void drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint)
    
// 第二种
public void drawArc(float left, float top, float right, float bottom, float startAngle,float sweepAngle, boolean useCenter, @NonNull Paint paint)
```

`drawArc()` 是使用一个椭圆来描述弧形的。`left`, `top`, `right`, `bottom` 描述的是这个弧形所在的椭圆；`startAngle` 是弧形的起始角度（x 轴的正向，即正右的方向，是 0 度的位置；顺时针为正角度，逆时针为负角度），`sweepAngle` 是弧形划过的角度；`useCenter` 表示是否连接到圆心，如果不连接到圆心，就是弧形，如果连接到圆心，就是扇形。

``` kotlin
    mPaint.style = Paint.Style.FILL //设置填充模式
    mPaint.color = Color.BLACK  //设置画笔颜色
    mPaint.strokeWidth = 20f    //设置画笔宽度为20px

    canvas.drawArc(200f, 100f, 800f, 500f, -90f, 90f, true, mPaint) // 绘制扇形
    canvas.drawArc(200f, 100f, 800f, 500f, 20f, 90f, false, mPaint) // 绘制弧形

    mPaint.style = Paint.Style.STROKE // 描边模式
    canvas.drawArc(200f, 100f, 800f, 500f, 180f, 60f, false, mPaint) // 绘制不封口的弧形
```

![绘制圆弧](https://ForLovelj.github.io/img/绘制圆弧.png)

## 6. 绘制图片

### 6.1 drawBitmap

先预览一下drawBitmap的常用方法：

``` java
    // 第一种
    public void drawBitmap (Bitmap bitmap, Matrix matrix, Paint paint)
    
    // 第二种
    public void drawBitmap (Bitmap bitmap, float left, float top, Paint paint)
    
    // 第三种
    public void drawBitmap (Bitmap bitmap, Rect src, Rect dst, Paint paint)
    public void drawBitmap (Bitmap bitmap, Rect src, RectF dst, Paint paint)
```

第一种方法中后两个参数(matrix, paint)是在绘制的时候对图片进行一些改变，如何改变我们后面会讲到，如果只是需要将图片内容绘制出来只需要如下操作就可以了：

``` kotlin
    val bitmap = BitmapFactory.decodeResource(resources, R.mipmap.beauty)
    //第一种
    canvas.drawBitmap(bitmap,Matrix(),mPaint)
```

![绘制bitmap1](https://ForLovelj.github.io/img/绘制bitmap1.png)

第二种方法就是在绘制时指定了图片左上角的坐标(距离绘图坐标系坐标原点的距离)：

``` kotlin
    val bitmap = BitmapFactory.decodeResource(resources, R.mipmap.beauty)
    //第二种
    canvas.drawBitmap(bitmap,200f,200f,mPaint)
```

![绘制bitmap2](https://ForLovelj.github.io/img/绘制bitmap2.png)

第三种方法比较有意思，这里有2个Rect参数，其中src表示需要被绘制Bitmap的区域，即从Bitmap上取出需要绘制的区域；而dst则表示显示的区域，如果src规定的绘制区域大于dst的区域，图片大小会被缩放。

``` kotlin
    val bitmap = BitmapFactory.decodeResource(resources, R.mipmap.beauty)
    val src = Rect(0,0,bitmap.width,bitmap.height/2)    //指定图片绘制区域(图片上半部分)
    val dst = Rect(200,200,200+bitmap.width,200+bitmap.height/2)    //指定图片在屏幕上显示的区域
    canvas.drawBitmap(bitmap,src,dst,mPaint)    //绘制Bitmap
```

![绘制bitmap3](https://ForLovelj.github.io/img/绘制bitmap3.png)

从上面可知，第三种方法可以绘制图片的一部分到画布上，这有什么用呢？

如果你看过某些游戏的资源文件，你可能会看到如下的图片(图片来自网络)：

![boom](https://ForLovelj.github.io/img/boom.png)

用一张图片包含了大量的素材，在绘制的时候每次只截取一部分进行绘制，这样可以大大的减少素材数量，而且素材管理起来也很方便。

在某些时候我们需要制作一些炫酷的效果，这些效果因为太复杂了用代码很难实现或者渲染效率不高。这时候很多人就会想起帧动画，将动画分解成一张一张的图片然后使用帧动画制作出来，这种实现方式的确比较简单，但是一个动画效果的图片有十几到几十张，一个应用里面来几个这样炫酷的动画效果就会导致资源文件出现一大堆，想找其中的某一张资源图片简直就是灾难。但是把同一个动画效果的所有资源图片整理到一张图片上，会大大的减少资源文件数量，方便管理，同时也节省了图片文件头、文件结束块以及调色板等占用的空间。

我们以上面的爆炸效果图片利用drawBitmap第三种方法制作的一个简单示例：

``` kotlin
    private val boomBitmap = BitmapFactory.decodeResource(resources, R.mipmap.boom)
    private var level = 0   //最开始处于爆炸的第0片段
    private var frame = 0

    private fun drawBitmapDemo(canvas: Canvas) {
        frame++
        if(level >= 14)return
        //每两帧绘制一次爆炸
        if (frame % 2 == 0) {
            //爆炸效果由14个片段组成 算出每个片段的宽度
            val segmentWidth = boomBitmap.width / 14
            val left = level * segmentWidth

            val src = Rect(left,0,left+segmentWidth,boomBitmap.height)
            val dst = Rect(300,300,300+segmentWidth,300+boomBitmap.height)
            canvas.drawBitmap(boomBitmap,src,dst,mPaint)
            level++
        }
        invalidate()
    }
```

![boom2](https://ForLovelj.github.io/img/boom.gif)