---
layout: post
title: 03-Canvas绘图基础详解.md
author: clow
date: 2021-02-22 20:20:15
categories:
- Android
tags: 自定义View
---

# 一、前言
Android中，如果我们想绘制复杂的自定义View或游戏，我们就需要熟悉绘图API。Android通过Canvas类暴露了很多drawXXX方法，我们可以通过这些方法绘制各种各样的图形。Canvas绘图有三个基本要素：Canvas、绘图坐标系以及Paint。Canvas是画布，我们通过Canvas的各种drawXXX方法将图形绘制到Canvas上面，在drawXXX方法中我们需要传入要绘制的图形的坐标形状，还要传入一个画笔Paint。drawXXX方法以及传入其中的坐标决定了要绘制的图形的形状，比如drawCircle方法，用来绘制圆形，需要我们传入圆心的x和y坐标，以及圆的半径。drawXXX方法中传入的画笔Paint决定了绘制的图形的一些外观，比如是绘制的图形的颜色，再比如是绘制圆面还是圆的轮廓线等。

# 二、Canvas的常用操作速查表

| 操作类型       | 相关API                                    | 备注                                       |
| ---------- | ---------------------------------------- | ---------------------------------------- |
| 绘制颜色       | drawColor, drawRGB, drawARGB             | 使用单一颜色填充整个画布                             |
| 绘制基本形状     | drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc | 依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧                  |
| 绘制图片       | drawBitmap, drawPicture                  | 绘制位图和图片                                  |
| 绘制文本       | drawText,    drawPosText, drawTextOnPath | 依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字          |
| 绘制路径       | drawPath                                 | 绘制路径，绘制贝塞尔曲线时也需要用到该函数                    |
| 顶点操作       | drawVertices, drawBitmapMesh             | 通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用 |
| 画布剪裁       | clipPath,    clipRect                    | 设置画布的显示区域                                |
| 画布快照       | save, restore, saveLayerXxx, restoreToCount, getSaveCount | 依次为 保存当前状态、 回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数 |
| 画布变换       | translate, scale, rotate, skew           | 依次为 位移、缩放、 旋转、错切                         |
| Matrix(矩阵) | getMatrix, setMatrix, concat             | 实际画布的位移，缩放等操作的都是图像矩阵Matrix，只不过Matrix比较难以理解和使用，故封装了一些常用的方法。 |

> PS： Canvas常用方法在上面表格中已经全部列出了，当然还存在一些其他的方法未列出，具体可以参考官方文档 [Canvas](http://developer.android.com/reference/android/graphics/Canvas.html)

# 三、Canvas Api梳理

## 1. Canvas坐标系

**Canvas坐标系：** Canvas坐标系指的是Canvas本身的坐标系，默认情况下与View的坐标系重合，其坐标原点在View的左上角，从坐标原点向右为x轴的正半轴，从坐标原点向下为y轴的正半轴。

为了更好的理解Canvas坐标系，请看如下代码：

``` kotlin

    /**
     * 绘制坐标系
     */
    private fun drawAxis(canvas: Canvas) {
        val canvasWidth = canvas.width.toFloat()
        val canvasHeight= canvas.height.toFloat()
        mPaint.setColor(Color.GREEN)
        mPaint.strokeWidth = 8f
        //第一次绘制坐标轴(默认情况下的绘图坐标系)
        canvas.drawLine(0f,0f,canvasWidth,0f,mPaint)//绘制x轴
        canvas.drawLine(0f,0f,0f,canvasHeight,mPaint)//绘制Y轴
        //绘制一个矩形
        mPaint.setColor(Color.BLUE)
        val rect = RectF(100F, 100F, 200F, 200F)
        canvas.drawRect(rect,mPaint)

        //对坐标系平移后，第二次绘制坐标轴
        canvas.translate(300f,300f)
        mPaint.setColor(Color.RED)
        canvas.drawLine(0f,0f,canvasWidth,0f,mPaint)//绘制x轴
        canvas.drawLine(0f,0f,0f,canvasHeight,mPaint)//绘制Y轴
        //绘制一个矩形
        mPaint.setColor(Color.BLUE)
        canvas.drawRect(rect,mPaint)

        //对坐标系旋转，第三次绘制坐标轴
        canvas.rotate(30f)
        mPaint.setColor(Color.BLACK)
        canvas.drawLine(0f,0f,canvasWidth,0f,mPaint)//绘制x轴
        canvas.drawLine(0f,0f,0f,canvasHeight,mPaint)//绘制Y轴
        //绘制一个矩形
        mPaint.setColor(Color.BLUE)
        canvas.drawRect(rect,mPaint)
    }

```

界面如下图所示：

![绘制坐标系](https://ForLovelj.github.io/img/绘制坐标系.png)

图中黑色坐标代表View的坐标系，红色的坐标代表Canvas的坐标系。

第一次绘制坐标轴时（绿色），可以看到，默认情况下View的坐标系和Canvas的坐标系重合

第二次绘制坐标轴时（红色），可以看到Canvas的坐标原点被移动到(300,300)，而View的坐标系没有改变，绘制内容是基于Canvas坐标系来绘制的。

第三次绘制坐标轴时（黑色），将Canvas的坐标系顺时针旋转了30°，View的坐标系还是没有改变，绘制内容是基于Canvas坐标系来绘制的。

从上我们可以知道，在绘制内容时是根据Canvas的坐标系来绘制的，我们对Canvas的操作只是改变了绘图坐标系跟View的坐标系无关。

## 2. 画布操作

画布的操作可以让我们绘制出更多的效果，这里要注意一点，就是画布Canvas的概念，虽然翻译为画布，其实它是绘制的规则，真正绘制是在屏幕上，所以当画布平移、裁剪等操作只针对于画布来说，对其View的大小和位置没有影响。

**Q：为什么要有画布操作？**

**A：画布操作可以帮助我们用更加容易理解的方式制作图形。**

**例如： 从坐标原点为起点，绘制一个长度为20dp，与水平线夹角为30度的线段怎么做？**

**按照我们通常的想法(被常年训练出来的数学思维)，就是先使用三角函数计算出线段结束点的坐标，然后调用drawLine即可。**

**然而这是否是被固有思维禁锢了？**

**假设我们先绘制一个长度为20dp的水平线，然后将这条水平线旋转30度，则最终看起来效果是相同的，而且不用进行三角函数计算，这样是否更加简单了一点呢？**

**合理的使用画布操作可以帮助你用更容易理解的方式创作你想要的效果，这也是画布操作存在的原因。**

### 2.1 平移(translate)

translate是坐标系的移动，可以为图形绘制选择一个合适的坐标系。 请注意，位移是基于当前位置移动，而不是每次基于屏幕左上角的(0,0)点移动，如下：

``` kotlin
       // 在坐标原点绘制一个黑色圆形
        mPaint.style = Paint.Style.FILL
        mPaint.setColor(Color.BLACK)
        canvas.translate(200f,200f)
        canvas.drawCircle(0f,0f,100f,mPaint)

        // 在坐标原点绘制一个蓝色圆形
        mPaint.setColor(Color.BLUE)
        canvas.translate(200f,200f)
        canvas.drawCircle(0f,0f,100f,mPaint)
```
效果如下：

![画布平移](https://ForLovelj.github.io/img/画布平移.png)

我们首先将坐标系移动一段距离绘制一个圆形，之后再移动一段距离绘制一个圆形，**两次移动是可叠加的**。 

### 2.2 缩放(scale)

缩放提供了两个方法，如下：
``` java
 public void scale (float sx, float sy)

 public final void scale (float sx, float sy, float px, float py)
```

这两个方法中前两个参数是相同的分别为x轴和y轴的缩放比例。而第二种方法比前一种多了两个参数，用来控制缩放中心位置的。

缩放比例(sx,sy)取值范围详解：

| 取值范围(n) | 说明                                           |
| ----------- | ---------------------------------------------- |
| (-∞, -1)    | 先根据缩放中心放大n倍，再根据中心轴进行翻转    |
| -1          | 根据缩放中心轴进行翻转                         |
| (-1, 0)     | 先根据缩放中心缩小到n，再根据中心轴进行翻转    |
| 0           | 不会显示，若sx为0，则宽度为0，不会显示，sy同理 |
| (0, 1)      | 根据缩放中心缩小到n                            |
| 1           | 没有变化                                       |
| (1, +∞)     | 根据缩放中心放大n倍                            |

如果在缩放时稍微注意一下就会发现**缩放的中心默认为坐标原点,而缩放中心轴就是坐标轴**，如下：

``` kotlin
    val canvasWidth = canvas.width.toFloat()
    val canvasHeight= canvas.height.toFloat()
    //画布原点平移到中心
    canvas.translate(canvasWidth/2,canvasHeight/2)
    //绘制坐标系
    mPaint.style = Paint.Style.STROKE
    mPaint.setColor(Color.RED)
    mPaint.strokeWidth = 4f
    canvas.drawLine(-canvasWidth/2,0f,canvasWidth/2,0f,mPaint)//x轴
    canvas.drawLine(0f,-canvasHeight/2,0f,canvasHeight/2,mPaint)//y轴


    val rect = RectF(0F, 0F, 400F, 400F)    // 矩形区域
    mPaint.setColor(Color.BLACK)
    canvas.drawRect(rect, mPaint)       //绘制黑色矩形

    canvas.scale(0.5f,0.5f)      // 画布缩放

    mPaint.setColor(Color.BLUE)
    canvas.drawRect(rect, mPaint)      //再绘制蓝色矩形
```

(为了更加直观，我添加了一个坐标系，可以比较明显的看出，缩放中心就是坐标原点)

![画布缩放1](https://ForLovelj.github.io/img/画布缩放1.png)

接下来我们使用第二种方法让缩放中心位置稍微改变一下，如下：

``` kotlin
    val rect = RectF(0F, 0F, 400F, 400F)    // 矩形区域
    mPaint.setColor(Color.BLACK)
    canvas.drawRect(rect, mPaint)       //绘制黑色矩形

    canvas.scale(0.5f,0.5f,200f,0f)   // 画布缩放  <-- 缩放中心向右偏移了200个单位

    mPaint.setColor(Color.BLUE)
    canvas.drawRect(rect, mPaint)      //再绘制蓝色矩形
```

![画布缩放2](https://ForLovelj.github.io/img/画布缩放2.png)

前面两个示例缩放的数值都是正数，按照表格中的说明，当缩放比例为负数的时候会根据缩放中心轴进行翻转，下面我们就来实验一下：

``` kotlin
    canvas.scale(-0.5f,-0.5f)         // 画布缩放
```

![画布缩放3](https://ForLovelj.github.io/img/画布缩放3.png)

为了效果明显，我对两个矩形中几个重要的点进行了标注，具有相同字母标注的点是一一对应的。

由于本次未对缩放中心进行偏移，所有默认的**缩放中心就是坐标原点，中心轴就是x轴和y轴**。

本次缩放可以看做是**先根据缩放中心(坐标原点)缩放到原来的0.5倍**，然后**分别按照x轴和y轴进行翻转**。

``` kotlin
    canvas.scale(-0.5f,-0.5f,200f,0f)  // 画布缩放  <-- 缩放中心向右偏移了200个单位
```

![画布缩放4](https://ForLovelj.github.io/img/画布缩放4.png)

本次对缩放中心点坐标进行了偏移，故中心轴也向右偏移了。**注意翻转是根据缩放中心轴进行的**。

**PS:和位移(translate)一样，缩放也是可以叠加的。**
``` kotlin
    canvas.scale(0.5f,0.5f)
    canvas.scale(0.5f,0.1f)
```

调用两次缩放则 x轴实际缩放为0.5x0.5=0.25 y轴实际缩放为0.5x0.1=0.05

下面我们利用这一特性制作一个有趣的图形。

``` kotlin
    val canvasWidth = canvas.width.toFloat()
    val canvasHeight= canvas.height.toFloat()
    //画布原点平移到中心
    canvas.translate(canvasWidth/2,canvasHeight/2)
    mPaint.style = Paint.Style.STROKE
    mPaint.setColor(Color.BLACK)
    mPaint.strokeWidth = 20f
    val rect = RectF(-400f, -400f, 400f, 400f) // 矩形区域

    for (i in 0..20) {
        canvas.scale(0.9f, 0.9f)
        canvas.drawRect(rect, mPaint)
    }
```

![画布缩放demo](https://ForLovelj.github.io/img/画布缩放demo.png)

### 2.3 旋转(rotate)

旋转提供了两种方法：

``` java
    public void rotate (float degrees)
  
    public final void rotate (float degrees, float px, float py)
```

和缩放一样，第二种方法多出来的两个参数依旧是控制旋转中心点的。

默认的旋转中心依旧是坐标原点：

``` kotlin
    val canvasWidth = canvas.width.toFloat()
    val canvasHeight= canvas.height.toFloat()
    //画布原点平移到中心
    canvas.translate(canvasWidth/2,canvasHeight/2)
    //绘制坐标系
    mPaint.style = Paint.Style.STROKE
    mPaint.setColor(Color.RED)
    mPaint.strokeWidth = 4f
    canvas.drawLine(-canvasWidth/2,0f,canvasWidth/2,0f,mPaint)//x轴
    canvas.drawLine(0f,-canvasHeight/2,0f,canvasHeight/2,mPaint)//y轴

    val rect = RectF(0F, 0F, 200F, 200F)
    mPaint.setColor(Color.BLACK)
    canvas.drawRect(rect, mPaint)   //绘制黑色矩形
    //顺时针旋转45°
    canvas.rotate(45f)

    //绘制旋转后的绿色坐标轴
    mPaint.setColor(Color.GREEN)
    canvas.drawLine(-canvasWidth/2,0f,canvasWidth/2,0f,mPaint)//x轴
    canvas.drawLine(0f,-canvasHeight/2,0f,canvasHeight/2,mPaint)//y轴

    mPaint.setColor(Color.BLUE)
    canvas.drawRect(rect, mPaint)   //绘制蓝色矩形
```

![画布旋转1](https://ForLovelj.github.io/img/画布旋转1.png)

旋转前canvas是红色坐标系，旋转后canvas是绿色坐标系，可以看到canvas沿着旋转中心顺时针旋转了45度。

改变旋转中心位置：

``` kotlin
    canvas.rotate(45f,100f,0f)  // 旋转45度 <-- 旋转中心向右偏移100个单位
```

![画布旋转2](https://ForLovelj.github.io/img/画布旋转2.png)

可以看到canvas是基于旋转中心旋转的。

**PS:同样，旋转也是可以叠加的。**

``` kotlin
    canvas.rotate(180)
    canvas.rotate(20)
```

调用两次旋转，则实际的旋转角度为180+20=200度。

为了演示这一个效果，我们来做一个刻度盘：

``` kotlin
    val canvasWidth = canvas.width.toFloat()
    val canvasHeight= canvas.height.toFloat()
    //画布原点平移到中心
    canvas.translate(canvasWidth/2,canvasHeight/2)
    mPaint.style = Paint.Style.STROKE
    mPaint.strokeWidth = 10f
    mPaint.setColor(Color.BLACK)
    canvas.drawCircle(0f,0f,400f,mPaint) //绘制表盘

    mPaint.strokeWidth = 4f
    val textPaint = TextPaint().apply {
        textSize = 18f
        isAntiAlias = true
        textAlign = Paint.Align.CENTER
    }
    for (i in 0..360 step 30) {
        canvas.drawLine(0f,-380f,0f,-400f,mPaint)   //绘制刻度
        if (i != 0) {
            canvas.save()
            canvas.rotate(-i.toFloat(),0f,-360f)    //逆时针旋转数字对应的角度 使数字全部正向
            canvas.drawText("${i/30}",0f,-360f,textPaint)   //绘制数字
            canvas.restore()
        }
        canvas.rotate(30f)
    }
```

![画布旋转demo](https://ForLovelj.github.io/img/画布旋转demo.png)

### 2.4 错切(skew)

skew这里翻译为错切，错切是特殊类型的线性变换。

错切只提供了一种方法：

``` java
    public void skew (float sx, float sy)
```

**参数含义：**

- float sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值.
- float sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值.

变换后的点(X,Y)和变换前的点(x,y)映射关系:

```
    X = x + sx * y
    Y = sy * x + y
```

示例：
``` kotlin
    val canvasWidth = canvas.width.toFloat()
    val canvasHeight= canvas.height.toFloat()
    //画布原点平移到中心
    canvas.translate(canvasWidth/2,canvasHeight/2)
    //绘制坐标系
    mPaint.style = Paint.Style.STROKE
    mPaint.setColor(Color.RED)
    mPaint.strokeWidth = 4f
    canvas.drawLine(-canvasWidth/2,0f,canvasWidth/2,0f,mPaint)//x轴
    canvas.drawLine(0f,-canvasHeight/2,0f,canvasHeight/2,mPaint)//y轴

    val rect = RectF(0F, 0F, 200F, 200F)
    mPaint.setColor(Color.BLACK)
    canvas.drawRect(rect, mPaint)   //绘制黑色矩形
    //画布往X方向倾斜45度
    canvas.skew(1f,0f)  // 水平错切 <- 45度

    mPaint.setColor(Color.BLUE)
    canvas.drawRect(rect, mPaint)   //绘制蓝色矩形
```

![画布错切](https://ForLovelj.github.io/img/画布错切.png)

通过上面说到的变化前后点位映射关系可以算出错切前的B(200,200),错且后的坐标为B'(400,200)。

## 3. 画布快照

### 3.1 快照(save)和回滚(restore)

**Q: 为什么存在快照与回滚**

**A：画布的操作是不可逆的，而且很多画布操作会影响后续的步骤，例如第一个例子，两个圆形都是在坐标原点绘制的，而因为坐标系的移动绘制出来的实际位置不同。所以会对画布的一些状态进行保存和回滚。**

与之相关的API:

| 相关API          | 简介                             |
| -------------- | ------------------------------ |
| save           | 把当前的画布的状态进行保存，然后放入特定的栈中        |
| saveLayerXxx   | 新建一个图层，并放入特定的栈中                |
| restore        | 把栈中最顶层的画布状态取出来，并按照这个状态恢复当前的画布  |
| restoreToCount | 弹出指定位置及其以上所有的状态，并按照指定位置的状态进行恢复 |
| getSaveCount   | 获取栈中内容的数量(即保存次数)               |

下面对其中的一些概念和方法进行分析：

1. 画布状态：当前画布经过的一些列操作。
2. 状态栈：存放画布状态和图层的栈，后进先出。

![画布状态栈](https://ForLovelj.github.io/img/画布状态栈.png)

3. 画布的构成：由多个图层构成：

![图层](https://ForLovelj.github.io/img/图层.png)

所以有如下结论：

- 在画布上操作 = 在图层上操作。
- 如无设置，绘制操作和画布操作默认是在默认图层上进行。
- 在通常情况下，使用默认图层可以满足需求；若需要绘制复杂的内容(比如地图)，则需要使用更多的图层。
- 最终显示的结果 = 所有图层叠在一起的效果。

#### SaveFlags

| 数据类型 | 名称                         | 简介                                       |
| ---- | -------------------------- | ---------------------------------------- |
| int  | ALL_SAVE_FLAG              | 默认，保存全部状态                                |
| int  | CLIP_SAVE_FLAG             | 保存剪辑区                                    |
| int  | CLIP_TO_LAYER_SAVE_FLAG    | 剪裁区作为图层保存                                |
| int  | FULL_COLOR_LAYER_SAVE_FLAG | 保存图层的全部色彩通道                              |
| int  | HAS_ALPHA_LAYER_SAVE_FLAG  | 保存图层的alpha(不透明度)通道                       |
| int  | MATRIX_SAVE_FLAG           | 保存Matrix信息(translate, rotate, scale, skew) |

#### save

save 有两种方法：

``` java
  // 保存全部状态
  public int save ()
  
  // 根据saveFlags参数保存一部分状态
  public int save (int saveFlags)
```

可以看到第二种方法比第一种多了一个saveFlags参数，使用这个参数可以只保存一部分状态，更加灵活，这个saveFlags参数具体可参考上面表格中的内容。

每调用一次save方法，都会在栈顶添加一条状态信息，以上面状态栈图片为例，再调用一次save则会在第5次上面载添加一条状态。

#### saveLayerXxx

saveLayerXxx有比较多的方法：

``` java
    // 无图层alpha(不透明度)通道
    public int saveLayer (RectF bounds, Paint paint)
    public int saveLayer (RectF bounds, Paint paint, int saveFlags)
    public int saveLayer (float left, float top, float right, float bottom, Paint paint)
    public int saveLayer (float left, float top, float right, float bottom, Paint paint, int saveFlags)

    // 有图层alpha(不透明度)通道
    public int saveLayerAlpha (RectF bounds, int alpha)
    public int saveLayerAlpha (RectF bounds, int alpha, int saveFlags)
    public int saveLayerAlpha (float left, float top, float right, float bottom, int alpha)
    public int saveLayerAlpha (float left, float top, float right, float bottom, int alpha, int saveFlags)
```

**注意：saveLayerXxx方法会让你花费更多的时间去渲染图像(图层多了相互之间叠加会导致计算量成倍增长)，使用前请谨慎，如果可能，尽量避免使用。**

使用saveLayerXxx方法，也会将图层状态也放入状态栈中，同样使用restore方法进行恢复。

#### restore
状态回滚，就是从栈顶取出一个状态然后根据内容进行恢复。

同样以上面状态栈图片为例，调用一次restore方法则将状态栈中第5次取出，根据里面保存的状态进行状态恢复。

#### restoreToCount
弹出指定位置以及以上所有状态，并根据指定位置状态进行恢复。

以上面状态栈图片为例，如果调用restoreToCount(2) 则会弹出 2 3 4 5 的状态，并根据第2次保存的状态进行恢复。

#### getSaveCount
获取保存的次数，即状态栈中保存状态的数量，以上面状态栈图片为例，使用该函数的返回值为5。

不过请注意，该函数的最小返回值为1，即使弹出了所有的状态，返回值依旧为1，代表默认状态。

#### 常用格式
虽然关于状态的保存和回滚啰嗦了不少，不过大多数情况下只需要记住下面的步骤就可以了：
``` java
   save();      //保存状态
   ...          //具体操作
   restore();   //回滚到之前的状态
```
这种方式也是最简单和最容易理解的使用方法。
