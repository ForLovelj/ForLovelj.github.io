---
layout: post
title: android Binder机制
author: clow
date: 2020-02-20 22:10:21
categories:
- Android
tags: Android
---
## 序
基于Android10分析更新

>Binder是Android系统进程间通信（IPC）方式之一。Linux已经拥有管道，system V IPC（消息队列/共享内存/信号量），socket等IPC手段，却还要倚赖Binder来实现进程间通信，说明Binder具有无可比拟的优势。

为什么要学习理解Binder?

作为 Android 工程师，是不是常常会有这样的疑问：

- 为什么 Activity 间传递对象需要序列化？
- Activity 的启动流程是什么样的？
- 四大组件底层的通信机制是怎样的？
- AIDL 内部的实现原理是什么？等等...

这些问题的背后都与 Binder 有莫大的关系，要弄懂上面这些问题理解 Bidner 通信机制是必须的。

本文主要站在Android开发的角度来大致解析下Binder在java层的一些知识原理，不会深入源码细节。重点如下：
1. 一些Linux的预备知识
2. Binder到底是什么？
3. Binder机制是如何跨进程的？
4. 一次Binder通信的基本流程是什么样？
5. 深入理解Java层的Binder
## 1. Linux 基础
由于Android系统基于Linux内核，我们有必要了解下Linux的一些基础
知识。
### 1.1 为什么需要跨进程通信（IPC）
![Linux进程隔离](https://ForLovelj.github.io/img/Linux进程隔离.png)
上图展示了 Liunx 中跨进程通信涉及到的一些基本概念：

- 进程隔离
- 进程空间划分：用户空间(User Space)/内核空间(Kernel Space)
- 系统调用：用户态/内核态

**进程隔离**
> 进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。

**虚拟内存地址空间**
在32位系统里，物理内存寻址大小为：4G。
![](https://ForLovelj.github.io/img/物理内存4g.png)


用32位表示一个地址块（上图的一个格子），最多能显示2^32个格子，也就是4 * 2^30 = 4G。

在编写程序的过程中，并不能直接访问物理内存地址。系统设计了虚拟地址（逻辑地址）来给每个进程分配地址空间。

![](https://ForLovelj.github.io/img/虚拟地址空间.png)

同样的，虚拟地址寻址空间也是4G。只是被分为了两部分：内核地址空间和用户地址空间。其中内核地址空间占用1G，用户地址空间占用3G。

普通的应用程序只能访问3G的用户空间，内核、驱动等运行在内核地址空间，每个进程内核地址空间是共享的。应用程序想要操作网络、磁盘等硬件资源需要通过内核来访问。

虚拟地址如何映射到物理内存呢？

![](https://ForLovelj.github.io/img/虚拟地址映射.png)

每个进程分配的虚拟地址空间都是独立的，通过页表映射到物理内存，进而读写数据。进程的虚拟地址空间既然是独立的，那么各个进程之间自然无法直接访问。

**用户空间/内核空间**

Linux Kernel是操作系统的核心，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。对于Kernel这么一个高安全级别的东西，显然是不容许其它的应用程序随便调用或访问的，所以需要对Kernel提供一定的保护机制，这个保护机制用来告诉那些应用程序，你只可以访问某些许可的资源，不许可的资源是拒绝被访问的，于是就把Kernel和上层的应用程序抽像的隔离开，分别称之为Kernel Space和User Space，如上图所示。

**用户态与内核态**

虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助系统调用来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。

Linux 使用两级保护机制：
- 0 级供系统内核使用
- 3 级供用户程序使用

当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。

当进程在执行用户自己的代码的时候，我们称其处于用户运行态（用户态）。此时处理器在特权级最低的（3级）用户代码中运行。

系统调用主要通过如下两个函数来实现：
```
copy_from_user() //将数据从用户空间拷贝到内核空间
copy_to_user() //将数据从内核空间拷贝到用户空间
```

### 1.2 Linux下的传统 IPC 通信原理
> 1、共享物理内存。  
2、通过内核中转。

#### 1.2.1 共享物理内存
多个进程共享同一段物理内存，当某个进程改变内存内容时，其它进程都能够知道。此种方式无需拷贝内容，但是需要信号量进行进程间同步。

![](https://ForLovelj.github.io/img/共享内存.png)

如图所示，进程A向进程B发送一段内容”hello world“，由于共享了内存，因此双方都可以直接从里面拿数据。享内存虽然无需拷贝，但控制复杂，难以使用。
### 1.2.2 通过内核中转
管道、消息队列、套接字(socket)使用的是这种方式

![](https://ForLovelj.github.io/img/内核中转.png)

同样是进程A向进程B发送一段内容：先将A发送的内容拷贝到内核，这过程可以理解为存储，再从内核拷贝到B的用户空间，这过程可以理解为转发，因此一次"存储-转发"过程需要两次内容拷贝。

虽然Linux提供了上述(还有其它的如信号量等)的IPC方式，但是由于每种方式都有其缺点，因此Android弄了另一种方式：Binder。

对比下各种IPC方式数据拷贝次数：

| IPC | 数据拷贝次数 |
| ------ | ------ |
| 共享内存 | 0 |
| Binder | 1 |
| Socket/管道/消息队列 | 2 |

## 2.Binder 通信模型
我们先来看下Binder实现层面是如何设计的，后面再去看它的实现原理。

Binder使用Client-Server通信方式，定义了四个角色：Server，Client，ServiceManager以及Binder驱动。其中Server，Client，SMgr运行于用户空间，驱动运行于内核空间。